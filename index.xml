<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yharim Area</title>
    <link>/</link>
    <description>Recent content on Yharim Area</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 09 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hugo 简介</title>
      <link>/docs/hugo/about/what-is-hugo/</link>
      <pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/docs/hugo/about/what-is-hugo/</guid>
      <description>Hugo 是一个 静态网站生成器。不同于「根据每个访客的请求动态构建网页」的系统，Hugo 在编辑网站内容时构建网页。这是因为网站的浏览频率远高于编辑频率。Hugo 旨在为网站的访客提供最佳的浏览体验，并为网站作者提供理想的写作体验。
使用 Hugo 构建网站快速且安全。Hugo 网站可以托管在很多地方，包括 Netlify，Heroku，GoDaddy，DreamHost，GitHub Pages，GitLab Pages，Surge，Firebase，Google 云盘，Amazon S3，Rackspace，Azure 和 CloudFront，并且可以与 CDN 配合使用。Hugo 网站不需要数据库，也不依赖昂贵的运行环境（如 Ruby，Python 或 PHP）。
Hugo 有多快#https://www.youtube.com/embed/CdiDYZ51a2o
Hugo 的工作方式#Hugo 根据当前目录下的各个 markdown 文件和 HTML 模板等构建网站。
Hugo 的目标群体#Hugo 适用于以下群体：
喜欢在文本编辑器而不是浏览器中写作的人。 希望自己搭建网站且不想设置复杂的运行环境、依赖关系和数据库的人。 希望搭建博客、公司网站、投资合作网站、文档、单个登录页面或具有上千个页面的网站的人。 </description>
    </item>
    
    <item>
      <title>快速开始</title>
      <link>/docs/hugo/getting-started/quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/hugo/getting-started/quick-start/</guid>
      <description>在本教程中，您将学习：
创建网站 添加内容 配置网站 发布网站 预备工作#在本教程开始之前，您需要：
安装 Hugo（最好是 extended 版本） 安装 Git 您还必须对命令行有一定的熟悉度。
创建网站#打开命令行，将当前位置更改到您的工作目录，并运行以下内容：
hugo new site quickstartcd quickstartgit initgit submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/anankeecho &amp;#34;theme = &amp;#39;ananke&amp;#39;&amp;#34; &amp;gt;&amp;gt; config.tomlhugo server 以下是对这些命令的解释：
在 /quickstart 中生成网站的 目录结构。
hugo new site quickstart 将当前位置更改到 /quickstart。
cd quickstart 在当前目录下初始化 Git 仓库。
git init 将 Ananke 主题 下载到 /themes/ananke 中，并将其作为 Git 子模块 添加到项目中。
git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke 在网站配置文件 config.</description>
    </item>
    
    <item>
      <title>网页结构</title>
      <link>/docs/hugo/content-management/organization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/hugo/content-management/organization/</guid>
      <description>Page Bundle#Hugo 0.32 开始使用 Page Bundle 组织内容文件。作者可以直接将图片等资源文件直接放在 md 文件的同一目录下，而不是放在千里之外的 /static 目录中。
假设您需要在 introduction.md 中通过 ![](author.png) 引入照片：
::: Hugo 0.32 之前： content/|-- post/|-- getting-started/|-- introduction.mdstatic/|-- post/|-- getting-started/|-- introduction/|-- author.png::: Hugo 0.32（使用 Page Bundle）： content/|-- post/|-- getting-started/|-- introduction.md|-- author.png阅读 Page Resources 和 Image Processing 以了解更多。
content 结构#假设网站主页的网址是 https://example.com/。
content/|-- about/| |-- index.</description>
    </item>
    
    <item>
      <title>Hugo 特性</title>
      <link>/docs/hugo/about/features/</link>
      <pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/docs/hugo/about/features/</guid>
      <description>基本特性#极快的构建速度（每个网页 1 ms 以内） 强大的主题功能 跨平台，易安装（支持 macOS，Linux，Windows 等） 使用 LiveReload 动态加载网页，编辑文章的同时可预览网站 网站易于托管 结构特性#清晰的项目结构（包括网站结构） 支持自定义 URL 格式 支持美化 URL 支持永久链接（Permalink）模式 支持通过路径别名（Aliases）重定向 支持自定义类别系统（taxonomy），包括分类（categories）和标签（tags）等 内置文章排序功能 自动生成文章目录 自动生成网站菜单 内容特性#支持原生 Markdown，Emacs Org-Mode 以及其它语法格式（详见 语法格式支持） 支持在导言区（front matter）使用 TOML，YAML 和 JSON 元数据格式 支持自定义网站主页 多样化的文章类型 支持自定义和自动生成文章摘要 支持自定义短代码（Shortcodes）以在 Markdown 中使用富文本 内置阅读时间评估功能 内置文章字数统计功能 其它特性#集成 Disqus 评论支持 集成 Google Analytics 支持 自动生成 RSS 支持在 HTML 中使用 Go 模板 代码块语法高亮（由 Chroma 提供支持） </description>
    </item>
    
    <item>
      <title>Hugo 安全问题</title>
      <link>/docs/hugo/about/security-model/</link>
      <pubDate>Sat, 14 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/docs/hugo/about/security-model/</guid>
      <description>运行时安全#Hugo 构建的是静态网站。构建后的网站运行在浏览器或和服务器（API）中。但在开发网站时，网站运行在 hugo 程序中。确保网站 运行时安全 十分重要。
Hugo 的主要措施：使用沙盒（虚拟文件系统）并制定严格的安全策略。
Hugo 内置有沙盒，仅主项目（而非第三方组件）可在沙盒根目录外挂载东西。 仅主项目可以遍历网站链接。 自定义组件对文件系统有只读权限。 Hugo 调用外部程序以支持 Asciidoctor 等功能，但这些程序及其传递参数是预定的，默认禁用（见 安全策略）。我们曾考虑添加 运行外部操作系统的命令 这一功能，但出于安全问题没有实现。 安全策略#Hugo 内置了安全策略，以限制对 os/exec、远程通信等的访问。以下是其默认配置。违反安全策略时，Hugo 将不会构建网站，并会给出解决方案。
=== config. === yaml
``` yamlsecurity:enableInlineShortcodes: falseexec:allow:- ^dart-sass-embedded$- ^go$- ^npx$- ^postcss$osEnv:- (?i)^((HTTPS?|NO)_PROXY|PATH(EXT)?|APPDATA|TE?MP|TERM)$funcs:getenv:- ^HUGO_- ^CI$http:methods:- (?i)GET|POSTurls:- .*```=== toml
``` toml[security]enableInlineShortcodes = false[security.</description>
    </item>
    
    <item>
      <title>Hugo 隐私配置</title>
      <link>/docs/hugo/about/hugo-and-gdpr/</link>
      <pubDate>Mon, 16 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/docs/hugo/about/hugo-and-gdpr/</guid>
      <description>通用数据保护条例 (GDPR) 是欧盟法律中关于数据保护和隐私的规定，适用于欧盟和欧洲经济区内的所有个人。该协议于 2018/5/25 生效。
Hugo 是静态网站生成器，构建的网站具有非常坚实的安全基础。与服务器和数据库驱动的网站相比，静态 HTML 文件更容易解析。
但即便是静态网站也可能与外部服务集成，所以从版本 0.41 开始，Hugo 提供隐私配置。
注意:
隐私配置默认为 false（即 Hugo 0.41 之前的工作方式）。 隐私配置适用于 内部模板。某些主题可能包含用于嵌入服务（如 Google Analytics）的自定义模板，这将使隐私配置不生效。 我们将继续更新，并在未来的 Hugo 版本中进一步改进。 全部隐私配置#以下是全部隐私配置及其默认值。此内容需放在网站配置文件（如 config.toml）中。
=== config. === yaml
``` yamlprivacy:disqus:disable: falsegoogleAnalytics:anonymizeIP: falsedisable: falserespectDoNotTrack: falseuseSessionStorage: falseinstagram:disable: falsesimple: falsetwitter:disable: falseenableDNT: falsesimple: falsevimeo:disable: falseenableDNT: falsesimple: falseyoutube:disable: falseprivacyEnhanced: false```=== toml</description>
    </item>
    
    <item>
      <title>静态网站生成器的优势</title>
      <link>/docs/hugo/about/benefits/</link>
      <pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/docs/hugo/about/benefits/</guid>
      <description>网站生成器将内容渲染成 HTML 文件。它们大多数是「动态网站生成器」——在用户访问网站时，动态地生成 HTML 文件。为了减小延迟，动态网站生成器会缓存其 HTML 文件。
Hugo 比缓存更进一步，一次性生成所有的 HTML 文件。你可以在本地查看这些文件，然后再把它们上传到托管静态网站的服务器上。由于 HTML 文件不是动态生成的，Hugo 属于「静态网站生成器」。
静态网站优势众多，其中最突出的是性能。解析相同数量的网页时，静态网站消耗的内存和 CPU 占用率远低于动态网站。
更多信息#「静态网站生成器简介」，David Walsh 「网页加载速度：Hugo 完胜 WordPress」, GettingThingsTech 「静态网站生成器」，O&amp;rsquo;Reilly 「StaticGen: 顶级开源静态网站生成器」（GitHub Stars） 「静态网站生成器 Top 10」，Netlify blog 「静态网站的崛起」，dotCMS </description>
    </item>
    
    <item>
      <title>License</title>
      <link>/docs/hugo/about/license/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/hugo/about/license/</guid>
      <description>Hugo v0.15 and later are released under the Apache 2.0 license. Earlier versions of Hugo were released under the Simple Public License.
Version 2.0, January 2004 https://www.apache.org/licenses/LICENSE-2.0
Terms and Conditions for use, reproduction, and distribution
1. Definitions#“License” shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.
“Licensor” shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</description>
    </item>
    
    <item>
      <title>为什么补码会是这个鬼样</title>
      <link>/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A5%E7%A0%81%E4%BC%9A%E6%98%AF%E8%BF%99%E4%B8%AA%E9%AC%BC%E6%A0%B7/</link>
      <pubDate>Mon, 09 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A5%E7%A0%81%E4%BC%9A%E6%98%AF%E8%BF%99%E4%B8%AA%E9%AC%BC%E6%A0%B7/</guid>
      <description>为什么使用补码#即答：想把减法转换为加法。
加法器的逻辑门电路易于设计、效率高。如果能把减法转换为加法，那么加减法就都能通过加法器进行，不需要额外设计减法器，能进一步简化芯片的设计。
具体怎么转换呢？
!!! info 减去一个数，等于加上这个数的相反数。
$$a-b=a+(-b)$$就是这一句废话文学给补码的理论奠大基。
补码是如何形成的#补码充分体现了什么叫作「bug 用得好就是特性」。
溢出#计算机中，储存数据的容器有一个重要的特性：溢出。
这是一个四位二进制数的容器，最多可以存到 $(15)_{10}=(1111)_2$。
$$\boxed{1} \ \boxed{1} \ \boxed{1} \ \boxed{1}$$
当我们把 $(10010)_2$ 存进该容器时，最高位的 $1$ 会被扔掉（悲），相当于减少了 $\color{red}(10000)_2$。
$$\cancel 1 \ \boxed{0} \ \boxed{0} \ \boxed{1} \ \boxed{0} \ \color{transparent}{\cancel 1}$$
这也就导致了，在长度为 $4$ 的容器中，$(10001)_2\Rightarrow(1)_2$，$(10010)_2\Rightarrow(10)_2$，$\cdots$
越加越小#在固定长度的容器中作加法，会出现「越加越小」的情况。还是拿长度 $4$ 的容器举例：
$$(1010)_2+(111)_2=(10001)_2\Rightarrow(1)_2$$
而我们又知道
$$(1010)_2+(-1001)_2=(1)_2$$
进一步说，在这样的环境下，给一个数加上负数 $(-1001)_2$，完全等价于给其加上正数 $(111)_2$。
有没有一种系统的方法，能给每个负数找到等价正数？
!!! note 以负数 $(-1001)_2$ 为例。设其等价正数为 $x$，参与加法的另一个常数为 $C$，则
$$C+(-1001)_2=C+x\color{red}-(10000)_2$$解得 $x={\color{red}(10000)_2}-(1001)_2=(111)_2$进一步说，对于一般的负数 $-y$，有</description>
    </item>
    
    <item>
      <title>伴侣点</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/%E4%BC%B4%E4%BE%A3%E7%82%B9/</link>
      <pubDate>Thu, 09 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/%E4%BC%B4%E4%BE%A3%E7%82%B9/</guid>
      <description>定义#对椭圆 $\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$，若 $x$ 轴的点 $M,N$ 满足 $x_M\cdot x_N=a^2$，则 $M,N$ 互为伴侣点。
!!! tip 若 $M,N$ 在 $y$ 轴，则应满足 $y_M\cdot y_N=b^2$。
性质#等角性#过其中任意一个伴侣点作弦 $CD$，均可产生等角。
$M,N$ 为伴侣点 $\intro k_{CN}+k_{DN}=0$ $M,N$ 为伴侣点 $\intro k_{CM}+k_{DM}=0$ 证明：设 $CD$ 斜率为 $k$，暴力计算求证。
互极性#由 极点极线方程 知识易得 $M,N$ 互极。
$$\frac{x_Mx_N}{a^2}+\frac{y_My_N}{b^2}=\frac{a^2}{a^2}=1$$
其它性质#椭圆 $\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$，$E(-m,0),F(m,0),Q(\frac{a^2}{m},0)$。
$y_M\cdot y_N=b^2\left(1-\frac{a^2}{m^2}\right)$ $k_{BM}\cdot k_{BN}=\frac{m-a}{m+a}(e^2-1)$ $k_{EM}\cdot k_{FN}=\frac{-b^2}{m^2+a^2}$ $\vec{EM}\cdot\vec{FN}=\frac{(a^2-m^2)(a^2+m^2-b^2)}{m^2}$ $\vec{FM}\cdot\vec{FN}=\frac{(a^2-m^2)(a^2-m^2+b^2)}{m^2}$ $\vec{AN}\cdot\vec{BM}=\frac{(a^2-m^2)(a^2-b^2)}{m^2}$ $\vec{FN}\cdot\vec{BM}=\frac{(a^2-m^2)(a^2+am-b^2)}{m^2}$ 统一的证明方法：设 $P$ 坐标，暴力计算求证。
!!! tip 明白是定值就够了。
推广#对于双曲线 $\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$，$M,N$ 为伴侣点 $\eq x_M\cdot x_N=a^2$。</description>
    </item>
    
    <item>
      <title>圆锥曲线简化模型</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%E7%AE%80%E5%8C%96%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 08 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%E7%AE%80%E5%8C%96%E6%A8%A1%E5%9E%8B/</guid>
      <description>等效判别式#原理#$$\begin{cases}\disp\frac{x^2}{m}&amp;#43;\frac{y^2}{n}=1\newlineAx&amp;#43;By&amp;#43;C=0\end{cases}$$
$$\Delta&amp;rsquo;=(A^2m+B^2n-C^2)$$
$$\Delta=4mnB^2\Delta&amp;rsquo;$$
!!! tip 对于双曲线 $\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$，将 $n$ 视作 $-b^2$。
使用例#$\frac{x^2}{4}+\frac{y^2}{3}=1$ 和 $y=kx+2$ 有两个交点，求 $k$ 的范围。
解：
$$\begin{cases}\disp\frac{x^2}{4}&amp;#43;\frac{y^2}{3}=1\newlinekx-y&amp;#43;2=0\end{cases}$$
$$\begin{matrix}m=4 &amp;amp; n=3 &amp;amp; \newlineA^2=k^2 &amp;amp; B^2=1 &amp;amp; C^2=4\end{matrix}$$
$$\Delta&amp;rsquo;=(4k^2+3-4)&amp;gt;0$$
$$k^2&amp;gt;\frac{1}{4}$$
$$k&amp;lt;-\frac{1}{2} \ \text{或} \ k&amp;gt;\frac{1}{2}$$
简化二次恒等式#原理#$$\begin{cases}b^2x^2&amp;#43;a^2y^2-a^2b^2=0\newlineAx&amp;#43;By&amp;#43;C=0\end{cases}$$
$$(a^2A^2&amp;#43;b^2B^2)x^2&amp;#43;(2a^2AC)x&amp;#43;(a^2C^2-a^2b^2B^2)=0$$
!!! tip 二倍爬山放中间，
直线平方交叉乘。``` latex\left[\begin{matrix}b^2 &amp;amp; &amp;amp; a^2 &amp;amp; &amp;amp; -a^2b^2 \newline&amp;amp; \large\times_1 &amp;amp; &amp;amp; \large\times_2 &amp;amp; \newlineA &amp;amp; &amp;amp; B &amp;amp; &amp;amp; C\end{matrix}\right]`````` latex({\large\times_{1^2}^+})x^2+(2\diagup\!</description>
    </item>
    
    <item>
      <title>自极三角形</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/%E8%87%AA%E6%9E%81%E4%B8%89%E8%A7%92%E5%BD%A2/</link>
      <pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/%E8%87%AA%E6%9E%81%E4%B8%89%E8%A7%92%E5%BD%A2/</guid>
      <description>!!! warning 需要 极点极线方程 的相关知识。
定义#:::
圆锥曲线任意内接四边形 $ABCD$，其边交点 $M,N$ 和对角线交点 $P$ 构成自极三角形。- $MN$ 是 $P$ 的极线- $MP$ 是 $N$ 的极线- $NP$ 是 $M$ 的极线:::
![](img/1-定义.jpg &amp;quot;15%&amp;quot;):-:证明#引理#Ceva 定理#$\Delta ABC$ 中，$AD,BE,CF$ 共点 $O$。
$\frac{BD}{DC}\cdot\frac{CE}{EA}\cdot\frac{AF}{FB}=1$ 证明：
$$\frac{BD}{DC}=\frac{S_{\Delta AOB}}{S_{\Delta AOC}},\frac{CE}{CA}=\frac{S_{\Delta BOC}}{S_{\Delta AOB}},\frac{AF}{FB}=\frac{S_{\Delta AOC}}{S_{\Delta BOC}}$$
代入即得
$$\frac{BD}{DC}\cdot\frac{CE}{EA}\cdot\frac{AF}{FB}=1$$
Ceva 定理还有角元形式
$$\frac{\sin\angle BAD}{\sin\angle CAD}\cdot\frac{\sin\angle CBE}{\sin\angle ABE}\cdot\frac{\sin\angle ACF}{\sin\angle BCF}=1$$
证明过程与边元形式大致相同。
证明过程都是充要的，故 Ceva 定理可逆用。</description>
    </item>
    
    <item>
      <title>极点极线方程</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/%E6%9E%81%E7%82%B9%E6%9E%81%E7%BA%BF%E6%96%B9%E7%A8%8B/</link>
      <pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/%E6%9E%81%E7%82%B9%E6%9E%81%E7%BA%BF%E6%96%B9%E7%A8%8B/</guid>
      <description>定义#极点和极线是双映射关系。
对椭圆 $\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$，任意一点 $P(x_0,y_0)$ 对应的极线为 $l:\frac{x_0x}{a^2}+\frac{y_0y}{b^2}=1$。同理，任意直线 $l$ 对应的极点为 $P$。
当极点 $P$ 位于不同的空间位置时，极线 $l$ 的几何意义有所区别。
P 在椭圆上#$l$ 为切线 证明：
$\because\frac{x_0^2}{a^2}+\frac{y_0^2}{b^2}=1,\therefore l$ 过点 $P$。
对于椭圆上任意非 $P$ 点 $(x_0&amp;rsquo;,y_0&amp;rsquo;)$ 有
$$\frac{x_0&amp;rsquo;^2}{a_2}+\frac{y_0&amp;rsquo;^2}{b^2}=1\not=\frac{x_0x_0&amp;rsquo;}{a^2}+\frac{y_0y_0&amp;rsquo;}{b^2}$$
即 $l$ 上有且仅有一点 $P$ 在椭圆上。$l$ 为切线。
P 在椭圆外#$l$ 为切点弦 证明：
设 $AB$ 为切点弦。下证 $A,B$ 在 $l$ 上。
由 $P$ 在椭圆上 得
$$PA:\frac{x_1x}{a^2}+\frac{y_1y}{b^2}=1,PB:\frac{x_2x}{a^2}+\frac{y_2y}{b^2}=1$$
将 $P(x_0,y_0)$ 分别代入
$$\begin{cases}\disp\frac{x_1x_0}{a^2}&amp;#43;\frac{y_1y_0}{b^2}=1\\\disp\frac{x_2x_0}{a^2}&amp;#43;\frac{y_2y_0}{b^2}=1\end{cases}$$
即 $(x_1,y_1),(x_2,y_2)$ 是方程 $\frac{x_0x}{a^2}+\frac{y_0y}{b^2}=1$ 的两解，即证 $A,B$ 在 $l$ 上。</description>
    </item>
    
    <item>
      <title>e² - 1 的应用</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/e2-1%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/e2-1%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>为什么使用 e² - 1#一个圆锥曲线第三定义的例子：
椭圆 双曲线 $k_{AP}\cdot k_{BP}=-\frac{b^2}{a^2}$ $k_{AP}\cdot k_{BP}=\frac{b^2}{a^2}$ 在椭圆中，$-\frac{b^2}{a^2}=e^2-1$，而在双曲线中 $\frac{b^2}{a^2}=e^2-1$。使用 $e^2-1$ 可以无视正负性的影响，将椭圆和双曲线的通用理论更好地串联起来。
应用 1#$$k_1\cdot k_2=e^2-1$$ 证明：
$$\begin{aligned}k_1\cdot k_2&amp;amp;=\frac{y_0}{x_0&amp;#43;a}\cdot\frac{y_0}{x_0-a}=\frac{y_0^2}{x_0^2-a^2} \\&amp;amp;=-\frac{b^2}{a^2}=e^2-1\end{aligned}$$
应用 2#$$k_1\cdot k_2=e^2-1$$ 证明：
$$\left.\begin{aligned}\disp\frac{x_0^2}{a^2}&amp;#43;\frac{y_0^2}{b^2}=1\\\disp\frac{x_1^2}{a^2}&amp;#43;\frac{y_1^2}{b^2}=1\end{aligned}\right\}\intro\frac{x_0^2-x_1^2}{a^2}&amp;#43;\frac{y_0^2-y_1^2}{b^2}=0$$
$$\begin{aligned}k_1\cdot k_2&amp;amp;=\frac{y_0-y_1}{x_0-x_1}\cdot\frac{y_0&amp;#43;y_1}{x_0&amp;#43;x_1}=\frac{y_0^2-y_1^2}{x_0^2-x_1^2}\\&amp;amp;=-\frac{b^2}{a^2}=e^2-1\end{aligned}$$
应用 3#$$k_1\cdot k_2=e^2-1$$ 证明：
$M\left(\frac{x_1+x_2}{2},\frac{y_1+y_2}{2}\right)$.
$$\left.\begin{aligned}\disp\frac{x_1^2}{a^2}&amp;#43;\frac{y_1^2}{b^2}=1\\\disp\frac{x_2^2}{a^2}&amp;#43;\frac{y_2^2}{b^2}=1\end{aligned}\right\}\intro\frac{x_1^2-x_2^2}{a^2}&amp;#43;\frac{y_1^2-y_2^2}{b^2}=0$$
$$\begin{aligned}k_1\cdot k_2&amp;amp;=\frac{y_1-y_2}{x_1-x_2}\cdot\frac{(y_1&amp;#43;y_2)/2}{(x_1&amp;#43;x_2)/2}=\frac{y_1^2-y_2^2}{x_1^2-x_2^2} \\&amp;amp;=-\frac{b^2}{a^2}=e^2-1\end{aligned}$$
应用 4#$$k_1\cdot k_2=e^2-1$$ 证明：</description>
    </item>
    
    <item>
      <title>平面几何</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/</guid>
      <description>距离公式#$(x_1,y_1)$ 到 $(x_2,y_2)$ 距离公式
$$d=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$
$(x_0,y_0)$ 到 $Ax+By+C=0$ 距离公式
$$d=\frac{|Ax_0+By_0+C|}{\sqrt{A^2+B^2}}$$
$Ax+By+C_1=0$ 到 $Ax+By+C_2=0$ 距离公式
$$d=\frac{|C_1-C_2|}{\sqrt{A^2+B^2}}$$
切线公式#切线长公式#过 $A(x_0,y_0)$ 作圆 $(x-a)^2+(y-b)^2=r^2$ 的一条切线，切点为 $B$，切线长为
$$AB=\sqrt{(x_0-a)^2+(y_0-b)^2-r^2}$$
切线 / 切点弦方程#过圆 $(x-a)^2+(y-b)^2=r^2$ 上一点 $P(x_0,y_0)$ 的切线方程为
$$l:(x_0-a)(x-a)+(y_0-b)(y-b)=r^2$$
过椭圆（双曲线）$\frac{x^2}{a^2}\pm\frac{y^2}{b^2}=1$ 上一点 $P(x_0,y_0)$ 的切线方程为
$$l:\frac{x_0\cdot x}{a^2}\pm\frac{y_0\cdot y}{b^2}=1$$
过抛物线 $y^2=2px$ 上一点 $P(x_0,y_0)$ 的切线方程为
$$l:y_0\cdot y=p(x_0+x)$$
当 $P$ 不在对应曲线上时，$l$ 表示切点弦方程。
公共弦方程#圆 $x^2+y^2+A_1x+B_1y+C_1=0$ 和 $x^2+y^2+A_2x+B_2y+C_2=0$ 的公共弦方程为
$$l:(A_1-A_2)x+(B_1-B_2)y+(C_1-C_2)=0$$
焦半径公式#坐标式#::: $$PF_1=a+ex_0,PF_2=a-ex_0$$::: $$PF_1=|ex_0+a|,PF_2=|ex_0-a|$$?</description>
    </item>
    
    <item>
      <title>立体几何</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E7%AB%8B%E4%BD%93%E5%87%A0%E4%BD%95/</link>
      <pubDate>Sat, 18 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E7%AB%8B%E4%BD%93%E5%87%A0%E4%BD%95/</guid>
      <description>基本公式#体积 表面积 柱体 $V=Sh$ $S=2\pi r(r+l)$ 锥体 $V=\frac{1}{3}Sh$ $S=\pi r(r+l)$ 台体 $V=\frac{1}{3}\left(S_1+S_2+\sqrt{S_1S_2}\right)h$ $S=\pi[r^2+R^2+l(r+R)]$ 法向量#交点倒数法#平面过 $(a,0,0),(0,b,0),(0,0,c)$，则法向量为 $\left(\frac{1}{a},\frac{1}{b},\frac{1}{c}\right)$。
平面平行于 $x$ 轴，且过 $(0,b,0),(0,0,c)$，则法向量为 $\left(0,\frac{1}{b},\frac{1}{c}\right)$。
!!! tip 坐标系可应用平移变换。
捺撇法#$\vec{PA}=(x_1,y_1,z_1),\vec{PB}=(x_2,y_2,z_2)$，平面 $PAB$ 法向量表示为：
$$\xymatrix@C=2em@R=2em {x_1 &amp;amp; y_1\ar@{-}[dr] &amp;amp; z_1\ar@{-}[dl]\ar@{-}[dr] &amp;amp; x_1\ar@{-}[dl]\ar@{-}[dr] &amp;amp; y_1\ar@{-}[dl] &amp;amp; z_1 \\x_2 &amp;amp; y_2 &amp;amp; z_2 &amp;amp; x_2 &amp;amp; y_2 &amp;amp; z_2}$$
$$(y_1z_2 - z_1y_2, z_1x_2 - x_1z_2, x_1y_2 - y_1x_2)$$</description>
    </item>
    
    <item>
      <title>扩展语法支持</title>
      <link>/posts/%E5%BB%BA%E7%AB%99/%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95%E6%94%AF%E6%8C%81/</link>
      <pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E5%BB%BA%E7%AB%99/%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95%E6%94%AF%E6%8C%81/</guid>
      <description>MkDocs 语法#Hint#::: markdown { title=Example, render=true }!!! note`markdown` text::: markdown { title=Example, render=true }!!! note Custom Title`markdown` text::: markdown { title=Example, render=true }??? note Collapsible`markdown` text::: markdown { title=Example, render=true }???+ note Collapsible Open`markdown` textHint 允许包含和嵌套任意内容。
???+ bug ???+ bug ???+ bug Nested bugs. MkDocs 一共支持 12 种 Hint。
::: !!! note markdown text ::: !</description>
    </item>
    
    <item>
      <title>哥德尔不完备性定理的证明</title>
      <link>/posts/%E6%9D%82%E9%A1%B9/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E6%80%A7%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E/</link>
      <pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%9D%82%E9%A1%B9/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E6%80%A7%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E/</guid>
      <description>!!! info 所有变量默认为自然数。
罗素悖论#!!! question 一个理发师要给所有「不给自己理发的人」理发，不给「给自己理发的人」理发，他是否应该给自己理发？
如果理发师给自己理发，他就属于「给自己理发的人」，但他不能给这类人理发，矛盾；如果他不给自己理发，他就属于「不给自己理发的人」，但他必须给这类人理发，也矛盾。
英国哲学家罗素（Russell）最早发现了这类悖论。罗素悖论的具体形式还有很多，比如：
我正在说的这句话是假话。 一张明信片的正面写「背面的话是真的」，背面写「正面的话是假的」。 一本书要列出所有「不列出自己书名的书」，这本书是否应该列出它自己？ 这些悖论都能以「朴素集合论」的形式概括：
设集合 $A=\{x\mid x\not\in A\}$
若 $x\in A$，则 $x\not\in A$ 若 $x\not\in A$，则 $x\in A$ 罗素最终构建了一个新的集合论系统 $\text{ZF(C)}$，取代了朴素集合论。$\text{ZF(C)}$ 通过对集合概念的限定，将 $A=\{x\mid x\not\in A\}$ 这种异端从集合的名单里剔除出去，从而规避了集合论中的罗素悖论。
但是，当我们离开集合论，来到自然数公理系统时，事情似乎变得更加复杂。
哥德尔不完备性定理#1931年，德国数学家库尔特·哥德尔（Kurt Gödel）在他的论文中提出了一个惊为天人的定理：
!!! quote 在蕴含 皮亚诺公理（自然数公理） 的公理系统中，必然存在一个「既不能证明，又不能证伪」的命题。
此定理揭示了公理系统的巨大的缺陷。此缺陷至今未被修复。
哥德尔的证明#哥德尔在皮亚诺公理的环境下找到了一个「罗素悖论」式的数学命题：
$$A:\neg A$$
若 $A$ 是真的，则 $A$ 是假的。 若 $A$ 是假的，则 $A$ 是真的。 命题 $A$ 就是「既不能证明，又不能证伪」的数学命题。
那么命题 $A$ 到底是什么？哥德尔是如何找到命题 $A$ 的？
哥德尔编码#哥德尔创造了一种编码算法，将数学语句编码为自然数。</description>
    </item>
    
    <item>
      <title>皮亚诺公理</title>
      <link>/posts/%E6%9D%82%E9%A1%B9/%E7%9A%AE%E4%BA%9A%E8%AF%BA%E5%85%AC%E7%90%86/</link>
      <pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%9D%82%E9%A1%B9/%E7%9A%AE%E4%BA%9A%E8%AF%BA%E5%85%AC%E7%90%86/</guid>
      <description>概述#皮亚诺公理（自然数公理）定义了一种形如「单向链表」的数数方法。
$$\xymatrix {0\ar[r] &amp;amp; 1\ar[r] &amp;amp; 2\ar[r] &amp;amp; 3\ar[r] &amp;amp; 4\ar[r] &amp;amp; \cdots}$$
为了在公理系统中严谨地使用「自然数」，数学家朱塞佩 · 皮亚诺（Giuseppe Peano）提出了五条公理。
公理一#!!! quote $0$ 是自然数。
自然数的起点诞生了。
公理二#!!! quote 任何自然数都有一个后继（$n$ 的后继记作 $sn$）。
自然数的雏形有了，大概长这样：
$$\xymatrix {0\ar[r] &amp;amp; 1\ar[r] &amp;amp; 2\ar[r] &amp;amp; 3\ar[r] &amp;amp; 4\ar[r] &amp;amp; \cdots}$$
但也有可能长这样：
$$\xymatrix {0\ar[r] &amp;amp; 1\ar[r] &amp;amp; 1\ar[r] &amp;amp; 4\ar[r] &amp;amp; 5\ar[r] &amp;amp; 1\ar[r] &amp;amp; 4\ar[r] &amp;amp; \cdots}$$</description>
    </item>
    
    <item>
      <title>速度增量法</title>
      <link>/posts/%E6%9D%82%E9%A1%B9/%E9%80%9F%E5%BA%A6%E5%A2%9E%E9%87%8F%E6%B3%95/</link>
      <pubDate>Sat, 25 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%9D%82%E9%A1%B9/%E9%80%9F%E5%BA%A6%E5%A2%9E%E9%87%8F%E6%B3%95/</guid>
      <description>简介#质量 $m_1$，速度 $v_1$ 的小球与质量 $m_2$，速度 $v_2$ 的小球弹性碰撞，无动能损失，则碰后速度 $v_1&amp;rsquo;,v_2&amp;rsquo;$ 满足
$$\begin{gather}v_1&amp;#43;v_1&amp;#39;=2v_{共}\\v_2&amp;#43;v_2&amp;#39;=2v_{共}\\v_{共}=\frac{m_1v_1&amp;#43;m_2v_2}{m_1&amp;#43;m_2}\end{gather}$$
简记为
$$\xymatrix@C=2em@R=.5em{v_1\ar@{-}[dr] &amp;amp; &amp;amp; v_2&amp;#39;\\&amp;amp; v_{共}\ar@{-}[dr]\ar@{-}[ur] &amp;amp; \\v_2\ar@{-}[ur] &amp;amp; &amp;amp; v_1&amp;#39;}$$
出现负值表示反向. 若可能存在动能损失，碰后实际速度 $v_{1实}\in[v_{共},v_1&amp;rsquo;],v_{2实}\in[v_{共},v_2&amp;rsquo;]$. 原理#由动量定理和动能定理得
$$\begin{gather*}&amp;amp;m_1v_1&amp;#43;m_2v_2=m_1v_1&amp;#39;&amp;#43;m_2v_2&amp;#39;\tag{1}\\&amp;amp;\disp\frac{1}{2}m_1v_1^2&amp;#43;\frac{1}{2}m_2v_2^2=\frac{1}{2}m_1v_1&amp;#39;^2&amp;#43;\frac{1}{2}m_2v_2&amp;#39;^2\tag{2}\end{gather*}$$
由 $(1)$ 得
$$m_1(v_1-v_1&amp;#39;)=-m_2(v_2-v_2&amp;#39;)\tag{3}$$
由 $(2)$ 得
$$\begin{gather}m_1v_1^2&amp;#43;m_2v_2^2=m_1v_1&amp;#39;^2&amp;#43;m_2v_2&amp;#39;^2\\m_1(v_1^2-v_1&amp;#39;^2)&amp;#43;m_2(v_2^2-v_2&amp;#39;^2)=0\\m_1(v_1-v_1&amp;#39;)(v_1&amp;#43;v_1&amp;#39;)&amp;#43;m_2(v_2-v_2&amp;#39;)(v_2&amp;#43;v_2&amp;#39;)=0\end{gather}$$
将 $(3)$ 代入
$$\begin{align*}v_1&amp;#43;v_1&amp;#39;=v_2&amp;#43;v_2&amp;#39;\\v_2&amp;#39;=v_1&amp;#43;v_1&amp;#39;-v_2\tag{4}\end{align*}$$
将 $(4)$ 代入 $(1)$
$$\begin{gather}m_1v_1&amp;#43;m_2v_2=m_1v_1&amp;#39;&amp;#43;m_2(v_1&amp;#43;v_1&amp;#39;-v_2)\\(m_1&amp;#43;m_2)v_1&amp;#39;=v_1(m_1-m_2)&amp;#43;2m_2v_2\\v_1&amp;#39;=\frac{v_1(m_1-m_2)&amp;#43;2m_2v_2}{m_1&amp;#43;m_2}\end{gather}$$</description>
    </item>
    
    <item>
      <title>大同小异</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E5%A4%A7%E5%90%8C%E5%B0%8F%E5%BC%82/</link>
      <pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E5%A4%A7%E5%90%8C%E5%B0%8F%E5%BC%82/</guid>
      <description>!!! warning 未经严格证明的理论！慎用！
简介#若 构造函数 题满足
$f&amp;rsquo;(x)$ 的不等号与 $f(x)$ 的相同. $f(x_0)$ 是 $f(x)$ 的唯一定值. 则答案必为 $(x_0,+\infty)$.
若不等号相反，则必为 $(-\infty,x_0)$.
!!! info - $f&amp;rsquo;(x)$ 和 $f(x)$ 必须移项至不等号左侧，且系数为正. - 同一不等式中同时出现 $f&amp;rsquo;(x)$ 与 $f(x)$，则此不等号应归为 $f&amp;rsquo;(x)$. - 若 $f(x)$ 定义域不为 $\mathbb R$，则答案需调整至定义域内.
原理#Under Construction ...
例 1#$f(x)$ 定义域为 $\mathbb R,f(-1)=3,f&amp;rsquo;(x)&amp;lt;3$，则 $f(x)&amp;gt;3x+6$ 的解集为
$$A.\ (-1,1)\qquad B.\ (-1,+\infty)\qquad C.\ (-\infty,-1)\qquad D.\ \mathbb R$$
???+ note 常规解法 构造 $g(x)=f(x)-3x-6$，原问题等价于 $g(x)&amp;gt;0$ 的解集.
$g&#39;(x)=f&#39;(x)-3&amp;lt;0,\therefore g(x)\downarrow$.</description>
    </item>
    
    <item>
      <title>N1 互换</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%88%97/n1%E4%BA%92%E6%8D%A2/</link>
      <pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%88%97/n1%E4%BA%92%E6%8D%A2/</guid>
      <description>简介#表述 1#$a_n=\frac{b}{(kn+p)(kn+q)}$. 若 $a_n$ 满足
$(kn+p)(kn+q)=0$ 的两根 $n_1-n_2=1$. 大根 $n_1$ 所在的位置是 $(kn+p)$，即 $kn_1+p=0$. 则 $\{a_n\}$ 的前 $n$ 项和为
$$S_n=\frac{bn}{(k+p)(kn+q)}$$
若 $n_1-n_2\not=1$ 则不可使用 N1 互换.
表述 2#$a_n$ 为等差数列，则 $\frac{1}{a_na_{n+1}}$ 的前 $n$ 项和为
$$S_n=\frac{n}{a_1a_{n+1}}$$
容易证明同 表述 1 等价.
原理#$$\frac{1}{a_na_{n&amp;#43;1}}=\frac{1}{d}\cdot\frac{a_{n&amp;#43;1}-a_n}{a_na_{n&amp;#43;1}}=\frac{1}{d}\left(\frac{1}{a_n}-\frac{1}{a_{n&amp;#43;1}}\right)\\\begin{aligned}S_n&amp;amp;=\frac{1}{d}\left(\frac{1}{a_1}-\frac{1}{a_2}&amp;#43;\frac{1}{a_2}-\frac{1}{a_3}&amp;#43;\cdots&amp;#43;\frac{1}{a_n}-\frac{1}{a_{n&amp;#43;1}}\right)\\&amp;amp;=\frac{1}{d}\left(\frac{1}{a_1}-\frac{1}{a_{n&amp;#43;1}}\right)\\&amp;amp;=\frac{1}{d}\cdot\frac{a_{n&amp;#43;1}-a_1}{a_1a_{n&amp;#43;1}}\\&amp;amp;=\frac{n}{a_1a_{n&amp;#43;1}}\end{aligned}$$
例 1#已知 $a_n=\frac{1}{(2n+1)(2n+3)}$，则 $\{a_n\}$ 的前 $n$ 项和 $S_n=\underline{\textcolor{transparent}{whatthefuck}}$.
常规解法 1.裂项
$$a_n=\frac{1}{(2n+1)(2n+3)}=\frac{1}{2}\left(\frac{1}{2n+1}-\frac{1}{2n+3}\right)$$
2.求和
$$\begin{aligned}S_n&amp;amp;=a_1&amp;#43;a_2&amp;#43;a_3&amp;#43;\cdots&amp;#43;a_n\\&amp;amp;=\frac{1}{2}\left(\frac{1}{3}-\frac{1}{5}&amp;#43;\frac{1}{5}-\frac{1}{7}&amp;#43;\cdots&amp;#43;\frac{1}{2n&amp;#43;1}-\frac{1}{2n&amp;#43;3}\right)\\&amp;amp;=\frac{1}{2}\left(\frac{1}{3}-\frac{1}{2n&amp;#43;3}\right)\\&amp;amp;=\frac{n}{3(2n&amp;#43;3)}\end{aligned}$$</description>
    </item>
    
    <item>
      <title>端点效应</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E7%AB%AF%E7%82%B9%E6%95%88%E5%BA%94/</link>
      <pubDate>Tue, 14 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E7%AB%AF%E7%82%B9%E6%95%88%E5%BA%94/</guid>
      <description>简介#若 $f(x)$ 满足
$f(x_0)=0$. $f(x)\geq 0$ 在 $[x_0,+\infty)$ 恒成立. 则 $f&amp;rsquo;(x_0)\geq 0$. 需要检验充分性.
例 1#$f(x)=kx-\sin x,\forall x\in[0,+\infty),f(x)\geq 0$，求 $k$ 的范围.
证 $f&amp;rsquo;(x)=k-\cos x$.
$\because f(0)=0,f(x)\geq 0$ 在 $[0,+\infty)$ 恒成立，
$\therefore f&amp;rsquo;(0)=k-1\geq 0\eq k\geq 1$.
充分性检验：
$k\geq 1$ 时，$f&amp;rsquo;(x)=k-\cos x\geq 0,f(x)\uparrow,f(x)\geq f(0)=0$. 符合题意.
综上 $k\in[1,+\infty)$.
例 2#$f(x)=\ln\frac{1+x}{1-x}-k(x+\frac{x^3}{3}),\forall x\in(0,1),f(x)&amp;gt;0$，求 $k$ 的范围.
证 $f&amp;rsquo;(x)=\frac{2}{1-x^2}-k(1+x^2)=\frac{kx^4-k+2}{1-x^2}$.
$\because f(0)=\ln\frac{1+0}{1-0}-0=0,f(x)&amp;gt;0$ 在 $(0,1)$ 上恒成立，
$\therefore f&amp;rsquo;(0)=2-k\geq 0\eq k\leq 2$.
充分性检验：
$k\leq 2$ 时，$x\in(0,1),f&amp;rsquo;(x)=\frac{k(x^4-1)+2}{1-x^2}\geq 0,f(x)\uparrow,f(x)&amp;gt;f(0)=0$.</description>
    </item>
    
    <item>
      <title>泰勒展开</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/</link>
      <pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80/</guid>
      <description>简介#泰勒展开是用形如 $a_0+a_1x+a_2x^2+\cdots+a_nx^n$ 的函数逼近 $e^x,\ln x$ 等超越函数的技巧。
推导#在 $x=0$ 处展开#设 $f(x)$ 有 $n$ 阶导，$g(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n$.
令 $f(x)$ 和 $g(x)$ 在 $x=0$ 处的函数值和各阶导相等，这样 $f(x)$ 在 $x=0$ 附近的图像才能逼近 $g(x)$. 因此
$$\begin{aligned}&amp;amp;f(0)=g(0)=a_0\\&amp;amp;f&amp;#39;(0)=g&amp;#39;(0)=a_1\\&amp;amp;f&amp;#39;&amp;#39;(0)=g&amp;#39;&amp;#39;(0)=2a_2\\&amp;amp;f&amp;#39;&amp;#39;&amp;#39;(0)=g&amp;#39;&amp;#39;&amp;#39;(0)=3\times 2a_3\\&amp;amp;\cdots\\&amp;amp;f^{(n)}(0)=g^{(n)}(0)=n!\times a_n\end{aligned}$$
$\therefore a_n$ 的通项为 $a_i=\frac{f^{(i)}(0)}{i!}$. 即
$$f(x)\approx f(0)&amp;#43;\frac{f&amp;#39;(0)}{1!}x&amp;#43;\frac{f&amp;#39;&amp;#39;(0)}{2!}x^2&amp;#43;\frac{f&amp;#39;&amp;#39;&amp;#39;(0)}{3!}x^3&amp;#43;\cdots&amp;#43;\frac{f^{(n)}(0)}{n!}x^n$$
此式称为 $f(x)$ 在 $x=0$ 处的 $n$ 阶泰勒展开式.
在 $x=m$ 处展开#只需设 $g(x)=a_0+a_1(x-m)+a_2(x-m)^2+\cdots+a_n(x-m)^n$. 推导过程与 在 $x=0$ 处展开 并无二致.
$$f(x)\approx f(0)&amp;#43;\frac{f&amp;#39;(0)}{1!}(x-m)&amp;#43;\frac{f&amp;#39;&amp;#39;(0)}{2!}(x-m)^2&amp;#43;\cdots&amp;#43;\frac{f^{(n)}(0)}{n!}(x-m)^n$$</description>
    </item>
    
    <item>
      <title>极值点偏移</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E6%9E%81%E5%80%BC%E7%82%B9%E5%81%8F%E7%A7%BB/</link>
      <pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E6%9E%81%E5%80%BC%E7%82%B9%E5%81%8F%E7%A7%BB/</guid>
      <description>简介#已知 $f(x_1)=f(x_2)$，$x_0$ 是极值点，求证 $x_1+x_2&amp;gt;2x_0$ 或 $x_1x_2&amp;gt;x_0^2$. 这就是极值点偏移问题.
$$极值点不偏移$$
$$\frac{x_1+x_2}{2}=x_0$$
$$极值点左偏$$
$$\frac{x_1+x_2}{2}&amp;gt;x_0$$
$$极值点右偏$$
$$\frac{x_1+x_2}{2}&amp;lt;x_0$$
原理#以极值点左偏为例，求证 $x_1+x_2&amp;gt;2x_0$，即 $x_1&amp;gt;2x_0-x_2$.
若 $x_1$ 和 $m-x_2$ 在函数的 $\uparrow$ 区间，则 $f(x_2)&amp;gt;f(2x_0-x_2)$.
原命题转化为关于 $x_2$ 的单变量问题.
$x_1x_2&amp;gt;x_0^2$ 同理.
例题#$f(x)=\frac{x}{e^x}$，若 $f(x_1)=f(x_2)$ 且 $x_1\not=x_2$，求证 $x_1+x_2&amp;gt;2$.
证 $f&amp;rsquo;(x)=\frac{1-x}{e^x}$.
$x\in(-\infty,1),f&amp;rsquo;(x)&amp;gt;0,f(x)\uparrow$. $x\in(1,+\infty),f&amp;rsquo;(x)&amp;lt;0,f(x)\downarrow$. 不妨设 $x_1&amp;lt;1&amp;lt;x_2$.
$$x_1&amp;#43;x_2&amp;gt;2\eq x_1&amp;gt;2-x_2\eq f(x_1)&amp;gt;f(2-x_2)\eq f(x_2)&amp;gt;f(2-x_2)$$
于是转而证明 $f(x_2)-f(2-x_2)&amp;gt;0$，其中 $x_2&amp;gt;1$.
设 $g(x)=f(x)-f(2-x)=\frac{x}{e^x}-\frac{2-x}{e^{2-x}}$，即证 $g(x)$ 在 $(1,+\infty)$ 上恒 $&amp;gt;0$.
$g&amp;rsquo;(x)=\frac{1-x}{e^x}-\frac{1-x}{e^{2-x}}=(x-1)(e^{x-2}-e^{-x})$.
$\therefore x\in(1,+\infty),g&amp;rsquo;(x)&amp;gt;0,g(x)\uparrow$.
$\therefore g(x)&amp;gt;g(1)=f(1)-f(1)=0$. 命题得证.</description>
    </item>
    
    <item>
      <title>若松先生传</title>
      <link>/posts/%E6%96%87%E8%A8%80%E6%96%87/%E8%8B%A5%E6%9D%BE%E5%85%88%E7%94%9F%E4%BC%A0/</link>
      <pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%96%87%E8%A8%80%E6%96%87/%E8%8B%A5%E6%9D%BE%E5%85%88%E7%94%9F%E4%BC%A0/</guid>
      <description>南陵1番县2何氏，名若松，字羲之，号顶香居士，性情纯厚，好学能文，方正贤良文学材力之士。自幼善笔墨纸砚之事，能揽琴瑟琵琶，通《四书》，精《五经》。少偶得一通灵宝砚，以书成《兰亭集序》。其母魏氏大惊曰：“安得这般似王羲之真迹也！” 是以赐字 “羲之”。
时年九岁，客要3至其家，观羲之习书。怎见得：劲如金碧龙虎，排山倒海，斗转星移。其势磅礴，惊天地，泣鬼神，入木更三分。宛若行云流水，烟柳画桥，风帘翠幕。其境悠然，俏佳人，魅4春光，温柔富贵乡。客举5惊其材，羲之推以为通灵宝砚之用，再看时，方知客夙6以他砚换之。众笑曰：“羲之习字，刚柔并济，炉火纯青，功力之厚而不藏也！”
十六年入于太学，与葡县7卖菜吴氏相交甚笃。吴氏乃不修边幅8，游手好闲9之徒，淫邪好戏10之人。何不幸11染吴之邪气，日夜酒池肉林，骄奢淫逸，醉生梦死12，花天酒地13。较之夏桀、商纣14，有过而无不及。众愈不堪其举，侧身斜视，私以流闻15。何愈疏懒，笔墨渐废16，形容枯槁17，力不从心，遂一落千丈，同吴氏沦于次列。一日幡然醒悟，重整旗鼓，杜18吴氏奢靡之风，潜心专研19，奋起直追，遂名复列前位。后人佳20之曰：“羲之先生近吴氏而能持21，仙鹤据22狼狈而不与狼狈同志，此真若松也。”
是上乘之炙23必有孑孓24岂25之。若松先生平日清心寡欲，近竟不堪众扰，顶香居士竟与顶香居生决裂。虽避人耳目，却失了真性情。故余劝之不必予视一故。既出此文，记念若松先生，以警示其乌蝇之随，非诚勿扰。
[南陵]：东南丘陵，长江以南、从云贵高原以东直达海滨的广大地区。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[番县]：地瓜县，今福建福清。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[要]：同 “邀”，邀请。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[魅]：同 “媚”，美好可爱。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[举]：全，都。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[夙]：先前。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[葡县]：今福建莆田。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[不修边幅]：不注意衣着、容貌的整洁。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[游手好闲]：游荡懒散，不愿参加劳动。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[淫邪好戏]：作风淫荡，喜欢调戏女子。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[不幸]：意外。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[醉生梦死]：像喝醉酒和做梦一样，昏昏沉沉、糊里糊涂。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[花天酒地]：沉迷于酒色的腐化堕落生活。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[夏桀、商纣]：都是历史上著名的暴君。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[流闻]：流言，坏话。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[废]：旷废，懈怠。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[形容枯槁]：形体面貌像枯死的树木一样毫无生气。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[杜]：杜绝。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[专研]：钻研。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[佳]：同 “嘉”，赞美。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[持]：保持气节操守。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[据]：同 “踞”，盘踞。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[炙]：烤肉。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[孑孓]：蚊子的幼虫。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[岂]：同 “觊”，觊觎，渴望得到不属于自己的东西。&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>坐标系平移法</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/%E5%9D%90%E6%A0%87%E7%B3%BB%E5%B9%B3%E7%A7%BB%E6%B3%95/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%A0%E4%BD%95/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/%E5%9D%90%E6%A0%87%E7%B3%BB%E5%B9%B3%E7%A7%BB%E6%B3%95/</guid>
      <description>简介#若圆锥曲线题围绕某特殊点展开，可将坐标系原点平移至此点，减小计算量.
例 1#已知椭圆 $E:\frac{x^2}{4}+\frac{y^2}{3}=1$，过 $P(2, 1)$ 的直线 $l$ 与椭圆 $E$ 交于 $A,B$ 且 $\vec{OP}^2=4\vec{PA}\cdot\vec{PB}$，求 $l$ 的方程.
标答#联立 $\begin{cases}y=k(x-2)+1\\ \frac{x^2}{4}+\frac{y^2}{3}=1\end{cases}$ 得
$$(3&amp;#43;4k^2)x^2-8k(2k-1)x&amp;#43;16k^2-16k-8=0$$
$\Delta=[-8k(2k-1)]^2-4(3+4k^2)(16k^2-16k-8)&amp;gt;0$
$\therefore 32(6k+3)&amp;gt;0,k&amp;gt;-\frac{1}{2}$
$x_1+x_2=\frac{8k(2k-1)}{3+4k^2},x_1x_2=\frac{16k^2-16k-8}{3+k^2}$
$\because\vec{OP}^2=4\vec{PA}\cdot\vec{PB}$
$\therefore(x_1-2,y_1-1)\cdot(x_2-2,y_2-1)=\frac{5}{4}$
$\therefore [x_1x_2-2(x_1+x_2)+4] (1+k^2)=\frac{5}{4}$
$\therefore \left[\frac{16k^2-16k-8}{3+4k^2}-2\frac{8k(2k-1)}{3+4k^2}+4\right] (1+k^2)=\frac{4+4k^2}{3+4k^2}=\frac{5}{4}$
解得 $k=\pm\frac{1}{2},k=-\frac{1}{2}$ 不合题意，舍去.
$\therefore l:y=\frac{1}{2}x$.
快速解法#将坐标系原点平移至 $P(2,1)$. 为了区分坐标系，令 $\lambda=x-2,\mu=y-1$. 新坐标系中 $A(\lambda_1,\mu_1),B(\lambda_2,\mu_2)$.
设 $l:\mu=k\lambda$. 于是 $\vec{PA}\cdot\vec{PB}=(k^2+1)\lambda_1\lambda_2=\frac{5}{4}$.
联立 $\begin{cases}\mu=k\lambda\\ \frac{(\lambda+2)^2}{4}+\frac{(\mu+1)^2}{3}=1\end{cases}$ 得
$$(4k^2&amp;#43;3)\lambda^2&amp;#43;(12&amp;#43;8k)\lambda&amp;#43;4=0$$
$\Delta=192k+96&amp;gt;0,\therefore k&amp;gt;-\frac{1}{2}$.
$\lambda_1\lambda_2=\frac{4}{4k^2+3}$
代入得 $(k^2+1)\frac{4}{4k^2+3}=\frac{5}{4}$，解得 $k=\frac{1}{2}$. $\therefore y=\frac{1}{2}x$.</description>
    </item>
    
    <item>
      <title>一轮复习踩坑记录</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E4%B8%80%E8%BD%AE%E5%A4%8D%E4%B9%A0%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E4%B8%80%E8%BD%AE%E5%A4%8D%E4%B9%A0%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</guid>
      <description>未完待续.
答题规范#草稿工整. 计算不得跳步. 阅读题干时不得跳题. 软柿子先捏，先易后难. 一、数学工具#1. 集合#注意空集 $\emptyset$. 空集是任何集合的子集. 2. 逻辑用语#$\neg(\forall f(x)\in A)\eq(\exists f(x)\notin A)$. 3. 一元二次不等式#讨论二次项系数是否为 $0$. 两边同乘参数时注意正负. 注意端点能否取等. 4. 基本不等式#大题要写当且仅当. 不等号方向相同才能互推. 二、函数#1. 函数定义#$f:A\rightarrow B$，值域是 $B$ 的子集. 整数定义域： 错误：$x\in[l,r],x\in\mathbb{Z}$. 正确：$x\in\{x\mid l\leq x\leq r, x\in\mathbb{Z}\}$. 2. 单调性#若 $f(x)\uparrow$，则 $\dfrac{1}{f(x)}$ 未必 $\downarrow$，如 $f(x)=\dfrac{1}{x}$. $f(x)\uparrow,g(x)\uparrow\eq f(g(x))\uparrow$，反之亦然. 3. 奇偶性和对称性#奇偶函数定义域关于原点对称. 4. 幂、指、对函数#$f(x)=x^a(a\in\mathbb{Q},a\not=0)$，$a&amp;lt;0$ 时 $x\not=0$.</description>
    </item>
    
    <item>
      <title>猫变</title>
      <link>/posts/%E6%96%87%E8%A8%80%E6%96%87/%E7%8C%AB%E5%8F%98/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%96%87%E8%A8%80%E6%96%87/%E7%8C%AB%E5%8F%98/</guid>
      <description>蜀中有李氏，寡居，饲一猫，猫色橘，然三年不肥，人皆异之，或曰：“可有妙法？” 李氏笑而不答。
后有新邻张氏，夜闻李氏屋有嘤咛1，色心起，窥之。见有橘发女子，身形窈窕2，有猫耳猫尾，与李氏交媾3，一夜缠绵。乃知李氏橘猫不肥，盖因交媾耗力甚巨也。
张氏羡之，亦饲一猫，日夜呼斥之，曰：“且变！” 猫不理，张氏怒，殴之，猫亦怒，化虬须4赤发汉，张氏大骇，方知所饲乃雄猫也，欲走不脱，遭缚。翌日，张氏肛裂，而猫不知所踪矣。
[嘤咛]：声音清脆娇细。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[窈窕]：身材好。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[交媾(gòu)]：阴阳交合。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
[虬(qiú)须]：胡须蜷曲。&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>构造函数</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
      <description>简介#若已知 $f(x)&amp;gt;0$，则构造函数 $F(x)$，使 $F&amp;rsquo;(x)=\text{某正数}\times f(x)$，利用 $F(x)\uparrow$ 解题. $f(x)&amp;lt;0$ 同理.
例 1#已知 $f(x)+f&amp;rsquo;(x)&amp;gt;0$，$f(0)=1$，求证当 $x\in[0,+\infty)$ 时 $f(x)\geq\frac{1}{e^x}$.
???+ note 证明
构造 $g(x)=e^xf(x)$，则$$g&#39;(x)=e^xf(x)+e^xf&#39;(x)=e^x[f(x)+f&#39;(x)]&amp;gt;0$$$\therefore x\in[0,+\infty)$ 时，$g(x)\uparrow$，$g(x)\geq g(0)$，即 $e^xf(x)\geq e^0f(0)=1$.$\therefore f(x)\geq \frac{1}{e^x}$. 即证.基本构造#和差构造#$f&amp;rsquo;+g&amp;rsquo;&amp;gt;0\intro F=f+g$ $f&amp;rsquo;-g&amp;rsquo;&amp;gt;0\intro F=f-g$ 积商构造#$f&amp;rsquo;g+fg&amp;rsquo;&amp;gt;0\intro F=fg$ $f&amp;rsquo;g-fg&amp;rsquo;&amp;gt;0\intro F=\frac{f}{g}\big(g\not=0\big)$ 变形#含 $x$ 形构造#$xf&amp;rsquo;(x)+nf(x)&amp;gt;0\intro F(x)=x^nf(x)$ $xf&amp;rsquo;(x)-nf(x)&amp;gt;0\intro F(x)=\frac{f(x)}{x^n}\big(x\not=0\big)$ 含 $e$ 形构造#$f&amp;rsquo;(x)+nf(x)&amp;gt;0\intro F(x)=e^{nx}f(x)$ $f&amp;rsquo;(x)-nf(x)&amp;gt;0\intro F(x)=\frac{f(x)}{e^{nx}}$ 三角构造#$f(x)+f&amp;rsquo;(x)\tan x&amp;gt;0\intro F(x)=\sin x f(x)$</description>
    </item>
    
    <item>
      <title>不动点法</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%88%97/%E4%B8%8D%E5%8A%A8%E7%82%B9%E6%B3%95/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%88%97/%E4%B8%8D%E5%8A%A8%E7%82%B9%E6%B3%95/</guid>
      <description>本篇证明可略过.
不动点#函数不动点#$y=f(x)$ 与 $y=x$ 的交点是 $f(x)$ 的不动点，即不动点 $x_0$ 满足
$$f(x_0)=x_0$$
数列不动点#若 $a_n=f(a_{n-1})$，则 $f(x)$ 的不动点也是数列 $\{a_n\}$ 的不动点.
一次不动点#已知 $a_n=A\cdot a_{n-1}+B(A\not=0)$.
若 $\{a_n\}$ 有不动点 $x_0$，则 $\{a_n-x_0\}$ 是公比为 $A$ 的等比数列.
证 由 不动点 的定义得
$$Ax_0+B=x_0$$
$$\therefore B=x_0-Ax_0$$
$$\therefore a_n-x_0=A\cdot a_{n-1}+B-x_0=A(a_{n-1}-x_0)$$
$\therefore$ 数列 $\{a_n-x_0\}$ 是公比为 $A$ 的等比数列
齐次不动点#已知 $a_n=\dfrac{Aa_{n-1}+B}{Ca_{n-1}+D}(C\not=0,AD-BC\not=0)$.
单根#若 $\{a_n\}$ 有唯一不动点 $x_0$，则 $\left\{\dfrac{1}{a_n-x_0}\right\}$ 是公差为 $\dfrac{2C}{A+D}$ 的等差数列.
证 由 不动点 的定义得</description>
    </item>
    
    <item>
      <title>特征根法</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%88%97/%E7%89%B9%E5%BE%81%E6%A0%B9%E6%B3%95/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%88%97/%E7%89%B9%E5%BE%81%E6%A0%B9%E6%B3%95/</guid>
      <description>二次特征根#已知 $af_{n+2}+bf_{n+1}+cf_n=0$.
两边同除 $a$：
$$f_{n+2}+\frac{b}{a}f_{n+1}+\frac{c}{a}f_n=0$$
根据韦达定理，方程 $ax^2+bx+c=0$ 的解满足
$$\begin{cases}x_1&amp;#43;x_2=-\dfrac{b}{a}\\x_1\cdot x_2=\dfrac{c}{a}\end{cases}$$
代入化简得
$$f_{n+2}-(x_1+x_2)f_{n+1}+(x_1\cdot x_2)f_n=0$$
$$f_{n+2}-x_1f_{n+1}=x_2(f_{n+1}-x_1f_n)$$
$\therefore$ 数列 $\{f_{n+1}-x_1f_n\}$ 是公比为 $x_2$ 的等比数列.
由韦达定理的对称性知，$x_1,x_2$ 可互换.
$$f_{n+1}-x_1f_n=(f_2-x_1f_1)\cdot x_2^{n-1}\tag{1}$$ $$f_{n+1}-x_2f_n=(f_2-x_2f_1)\cdot x_1^{n-1}\tag{2}$$
联立 $(1)(2)$ 可解得 $f_n$ 通项.
例 已知 $f_1=f_2=1,f_{n+2}=f_{n+1}+f_n$，求 $f_n$ 的通项.
解：设 $f_{n+2}-rf_{n+1}=q(f_{n+1}-rf_n)$，
则 $f_{n+2}=(q+r)f_{n+1}-q\cdot rf_n$.
对比 $f_{n+2}=f_{n+1}+f_n$ 得
$$\begin{cases}q&amp;#43;r=1\\q\cdot r=-1\end{cases}$$
解得
$$\begin{cases}q=\cfrac{1-\sqrt{5}}{2}\\r=\cfrac{1&amp;#43;\sqrt{5}}{2}\end{cases}\quad\text{或}\quad\begin{cases}q=\cfrac{1&amp;#43;\sqrt{5}}{2}\\r=\cfrac{1-\sqrt{5}}{2}\end{cases}$$
∴ 数列 $\{f_{n+1}-rf_n\}$ 是以 $f_2-rf_1$ 为首项，$q$ 为公比的等比数列.</description>
    </item>
    
    <item>
      <title>三角函数公式</title>
      <link>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%85%AC%E5%BC%8F/</link>
      <pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%85%AC%E5%BC%8F/</guid>
      <description>诱导公式#奇变偶不变，符号看象限.
$ \sin{(2k\pi+α)}=\sin{α}$ $ \cos{(2k\pi+α)}=\cos{α}$ $ \tan{(2k\pi+α)}=\tan{α}$ $ \sin{(2k\pi-α)}=-\sin{α}$ $ \cos{(2k\pi-α)}=\cos{α}$ $ \tan{(2k\pi-α)}=-\tan{α}$ $ \sin{(\pi+α)}=-\sin{α}$ $ \cos{(\pi+α)}=-\cos{α}$ $ \tan{(\pi+α)}=\tan{α}$ $ \sin{(\pi-α)}=\sin{α}$ $ \cos{(\pi-α)}=-\cos{α}$ $ \tan{(\pi-α)}=-\tan{α}$ $ \sin{(\frac{\pi}{2}+α)}=\cos{α}$ $ \cos{(\frac{\pi}{2}+α)}=-\sin{α}$ $ \tan{(\frac{\pi}{2}+α)}=-\frac{1}{\tan{α}}$ $ \sin{(\frac{\pi}{2}-α)}=\cos{α}$ $ \cos{(\frac{\pi}{2}-α)}=\sin{α}$ $ \tan{(\frac{\pi}{2}-α)}=\frac{1}{\tan{α}}$ $ \sin{(\frac{3\pi}{2}+α)}=-\cos{α}$ $ \cos{(\frac{3\pi}{2}+α)}=\sin{α}$ $ \tan{(\frac{3\pi}{2}+α)}=-\frac{1}{\tan{α}}$ $ \sin{(\frac{3\pi}{2}-α)}=-\cos{α}$ $ \cos{(\frac{3\pi}{2}-α)}=-\sin{α}$ $ \tan{(\frac{3\pi}{2}-α)}=\frac{1}{\tan{α}}$ $ \sin{(-α)}=-\sin{α}$ $ \cos{(-α)}=\cos{α}$ $ \tan{(-α)}=-\tan{α}$ 和差角公式#$ \sin{(α+β)}=\sin{α}\cos{β}+\cos{α}\sin{β}$ $ \sin{(α-β)}=\sin{α}\cos{β}-\cos{α}\sin{β}$ $ \cos{(α+β)}=\cos{α}\cos{β}-\sin{α}\sin{β}$ $ \cos{(α-β)}=\cos{α}\cos{β}+\sin{α}\sin{β}$ $ \tan{(α+β)}=\frac{\tan{α}+\tan{β}}{1-\tan{α}\tan{β}}$ $ \tan{(α-β)}=\frac{\tan{α}-\tan{β}}{1+\tan{α}\tan{β}}$ 二倍角公式#降幂扩角 升幂缩角.</description>
    </item>
    
    <item>
      <title>换根 DP</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%8D%A2%E6%A0%B9-dp/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%8D%A2%E6%A0%B9-dp/</guid>
      <description>简介#换根 DP 是基于 树形 DP 的更高效算法. 通常设 $f[u]$ 表示以 $u$ 为树根时的解，进而推出 $f[$其它节点$]$.
例 1#给定一棵 $n$ 个点的树，请求出一个节点，使得以其为根时，所有节点的深度之和最大（根节点的深度为 $1$）.
$d[u]$：（以 $1$ 为树根时）$u$ 的深度.
$\text{size}[u]$：（以 $1$ 为树根时）以 $u$ 为根的子树的节点数.
$f[u]$：以 $u$ 为树根时的节点深度和.
以 $1$ 为根时：
flowchart1 --&amp;gt; 2 &amp;amp; 32 --&amp;gt; 4 &amp;amp; 53 --&amp;gt; 6 &amp;amp; 7 &amp;amp; 8 以 $3$ 为根时：
flowchart3 --&amp;gt; 1 &amp;amp; 6 &amp;amp; 7 &amp;amp; 81 --&amp;gt; 2 --&amp;gt; 4 &amp;amp; 5 观察发现，原先 $3$ 的子树中（包括 $3$）节点的深度减少了 $1$，而其余节点的深度增加了 $1$.</description>
    </item>
    
    <item>
      <title>矩阵快速幂</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>简介#矩阵快速幂能将 $O(n)$ 的线性递推优化成 $O(\log n)$.
矩阵#矩阵相当于二维数组.
矩阵 $A$ 有 $m$ 行 $n$ 列，称为 $m×n$ 矩阵，简记为 $A_{mn}$.
矩阵 $A$ 第 $i$ 行 $j$ 列的元素写作 $a_{ij}$.
$$A=\begin{bmatrix}a_{11}&amp;amp; a_{12}&amp;amp; \cdots &amp;amp; a_{1n}\\a_{21}&amp;amp; a_{22}&amp;amp; \cdots &amp;amp; a_{2n}\\\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\a_{m1}&amp;amp; a_{m2}&amp;amp; \cdots &amp;amp; a_{mn}\end{bmatrix}$$
单位矩阵#主对角线上的元素都为 $1$，其余元素为 $0$ 的 $n×n$ 矩阵称为 $n$ 阶单位矩阵，记作 $I_n$ 或 $E_n$.
$$I_n=\begin{bmatrix}1 &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0 \\0 &amp;amp; 1 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0 \\0 &amp;amp; 0 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 0 \\\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 1\end{bmatrix}$$</description>
    </item>
    
    <item>
      <title>莫比乌斯反演</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</guid>
      <description>!!! info 若无特殊说明，本章涉及的变量皆为正整数.
简介#由函数 $f$ 定义一个函数 $g$：
$$g(n)=\sum_{d\mid n}f(d)\quad\big(\text{或}\quad g(n)=\sum_{n\mid d}f(d)\big)$$
已知 $g(n)$，即可用莫比乌斯反演推出 $f(n)$.
莫比乌斯函数#定义#$n$ 的莫比乌斯函数记为 $\mu(n)$：
$$\mu(n)=\begin{cases}0 &amp;amp; n \ 有平方因数 \\1 &amp;amp; n \ 无平方因数，且有偶数个质因数 \\-1 &amp;amp; n \ 无平方因数，且有奇数个质因数\end{cases}$$
特别地，$μ(1)=1$.
性质#性质 1#$$\sum_{d\mid n}μ(d)= \left\lfloor\frac{1}{n}\right\rfloor= \begin{cases}1 &amp;amp; n=1\\0 &amp;amp; n&amp;gt;1\end{cases}$$
证 设 $n$ 有 $k$ 个质因子 $p_1,p_2,\cdots,p_k$，则：
$$\begin{aligned}\sum_{d\mid n}μ(d)= \ &amp;amp;μ(1)&amp;#43;μ(p_1)&amp;#43;μ(p_2)&amp;#43;\cdots&amp;#43;μ(p_k)&amp;#43;μ(p_1p_2)&amp;#43;\cdots&amp;#43;μ(p_1p_2\cdots p_k)\\= \ &amp;amp;{k\choose 0}&amp;#43;{k\choose 1}(-1)&amp;#43;{k\choose 2}(-1)^2&amp;#43;\cdots&amp;#43;{k\choose k}(-1)^k\\= \ &amp;amp;\sum_{i=0}^k{k\choose i}(-1)^i\end{aligned}$$</description>
    </item>
    
    <item>
      <title>博弈论</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%8D%9A%E5%BC%88%E8%AE%BA/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%8D%9A%E5%BC%88%E8%AE%BA/</guid>
      <description>简介#博弈论研究在一局博弈中如何最优化玩家的策略.
公平组合游戏 ICG#两名玩家轮流行动，且行动规则相同. 最终不能行动的玩家判负. NIM 游戏#简介#有 $n$ 堆石子，第 $i$ 堆石子数为 $A_i$. 两名玩家轮流取走任意一堆的任意个石子，但不能不取. 取走最后一个石子的玩家胜.
NIM 游戏属于 公平组合游戏，且不存在平局，只有「先手必胜」和「后手必胜」两种情况.
策略#当且仅当 $A_1\oplus A_2\oplus\cdots\oplus A_n\not=0$ 时，先手必胜（$\oplus$ 表示二进制异或）.
$A\oplus B$：将 $A$ 和 $B$ 的二进制位对齐，相等取 $0$，不相等取 $1$.
$$\begin{aligned}1 \ 0 \ 0 \ 1 \ 0 \ 1 \ 0\\\underline{\oplus \ 1 \ 1 \ 0 \ 1 \ 1 \ 0 \ 1}\\0 \ 1 \ 0 \ 0 \ 1 \ 1 \ 1\end{aligned}$$</description>
    </item>
    
    <item>
      <title>容斥原理</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</guid>
      <description>!!! info 若无特殊说明，本章涉及的变量皆为正整数.
简介#容斥原理是一种不重不漏的计数原理.
例，$A,B,C$ 三人竞选扫黄队长：
::: - $15$ 人投给 $A$ - $16$ 人投给 $B$ - $17$ 人投给 $C$ - $2$ 人同时投给 $A,B,C$ ::: - $4$ 人同时投给 $A,B$ - $5$ 人同时投给 $A,C$ - $6$ 人同时投给 $B,C$
问共有多少人参与投票.
$A,B,C$ 三人的得票情况以用韦恩图描述：
::: - $|A|=15$ - $|B|=16$ - $|C|=17$ - $|A∩B∩C|=2$ ::: - $|A∩B|=4$ - $|A∩C|=5$ - $|B∩C|=6$
求的是投票人数，即 $|A∪B∪C|$.
$$|A∪B∪C|=|A|+|B|+|C|-|A∩B|-|A∩C|-|B∩C|+|A∩B∩C|$$
将上述问题推广到普遍情况，就是容斥原理.
公式#并集#对于 $n$ 个集合 $S_1,S_2\cdots S_n$，$|S|$ 表示集合 $S$ 的元素数，则：</description>
    </item>
    
    <item>
      <title>中国剩余定理</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</link>
      <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</guid>
      <description>若无特殊说明，本章涉及的变量皆为正整数.
简介#中国剩余定理最早发现于《孙子算经》中.
有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二. 问物几何？
即求满足下列条件的 $x$：
$$\left\{\begin{aligned}x \bmod 3 = 2 \\x \bmod 5 = 3 \\x \bmod 7 = 2 \\\end{aligned}\right.$$
它的通解公式为 $x=233+105k$.
《孙子算经》中只给出了最小正整数解，也就是 $k=-2$ 时的解：$x=23$.
不过，今天我们只关心中国剩余定理更普遍的应用.
问题#中国剩余定理指关于 $x$ 的同余方程组的解法：
$$\left\{\begin{aligned}x&amp;amp;≡a_1 \ (\bmod \ m_1)\\x&amp;amp;≡a_2 \ (\bmod \ m_2)\\&amp;amp;\cdots\\x&amp;amp;≡a_k \ (\bmod \ m_k)\end{aligned}\right.$$
其中 $a_1, a_2, \cdots, a_k$ 两两互质.
解法#设 $M=\prod^k_{i=1}m_i$.
设 $ M_i=\frac{M}{m_i}$，即除 $m_i$ 外，其余所有 $m$ 的乘积.</description>
    </item>
    
    <item>
      <title>Lucas 定理</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/lucas-%E5%AE%9A%E7%90%86/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/lucas-%E5%AE%9A%E7%90%86/</guid>
      <description>若无特殊说明，本章涉及的变量皆为正整数.
简介#Lucas 定理用于求解大组合数对质数 $p$（$p≤10^6$）取模：
$${n\choose m}≡{n \bmod p\choose m \bmod p}\cdot{\lfloor n/p\rfloor\choose\lfloor m/p\rfloor} \ (\bmod \ p)$$
证明#我不会，长大后再学习.
解法#对于 $n,m≤10^6$ 的组合数 ${n\choose m}$，可以直接代入 公式，并使用 乘法逆元 将除法转为乘法.
$$\binom{n}{m}=\frac{n!}{m!(n-m)!}≡n!\cdot(m!)^{-1}\cdot[(n-m)!]^{-1} \ (\bmod \ p)$$
/* fac[x]: x! * inv[x]: x! 关于模 p 的乘法逆元（注意有阶乘） * 以上需要预处理 */ LL C(LL n, LL m) { if (n &amp;lt; m) return 0; return fac[n] * inv[m] % P * inv[n - m] % P; } 对于更大的组合数，套用 Lucas 定理.</description>
    </item>
    
    <item>
      <title>卡特兰数列</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E5%88%97/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E5%88%97/</guid>
      <description> 若无特殊说明，本章涉及的变量皆为正整数.
简介#卡特兰数列是许多看似毫不相关的问题的解.
$n$ 个节点能构成 $Cat_n$ 种不同的二叉树. $n$ 个左括号和 $n$ 个右括号组成的合法序列有 $Cat_n$ 种. $n$ 个元素的进栈顺序为 $1,2,\cdots,n$，合法的出栈顺序有 $Cat_n$ 种. 在圆上选择 $2n$ 个点成对连接，使得 $n$ 条线段不相交的方法数为 $Cat_n$. 通过若干条互不相交的对角线,把凸 $n$ 边形拆分成若干个三角形的方案数为 $Cat_{n-2}$. 在平面直角坐标系上，每一步只能向上或向右走 $1$ 个单位，从 $(0,0)$ 走到 $(n,n)$ 且不接触直线 $y=x$ 的路径数量为 $2Cat_n-1$. 通项公式#$$Cat_n={2n\choose n}÷(n+1)={2n\choose n}-{2n\choose n-1}$$
递推公式#$$Cat_n=\sum_{i=0}^{n-1}Cat_i\cdot Cat_{n-i+1}$$
附表#$Cat_0$ $Cat_1$ $Cat_2$ $Cat_3$ $Cat_4$ $Cat_5$ $Cat_6$ $Cat_7$ $Cat_8$ $\cdots$ $1 $ $1 $ $2 $ $5 $ $14 $ $42 $ $132 $ $429 $ $1430 $ $\cdots$ </description>
    </item>
    
    <item>
      <title>二项式定理</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/</link>
      <pubDate>Sun, 22 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/</guid>
      <description>注意：若无特殊说明，本章涉及的变量皆为正整数.
简介#$$(a+b)^n=\sum_{i=0}^n\binom{n}{i}a^{n-i}b^i$$
证明#使用数学归纳法.
设 $n=k$ 时二项式定理成立，考察 $n=k+1$ 时是否也成立：
$$\begin{aligned}&amp;amp;\textcolor{transparent}{=}(a&amp;#43;b)^{k&amp;#43;1}\\&amp;amp;=(a&amp;#43;b)\cdot(a&amp;#43;b)^k\\&amp;amp;=a(a&amp;#43;b)^k&amp;#43;b(a&amp;#43;b)^k\\&amp;amp;=a\sum_{i=0}^k\binom{k}{i}a^{k-i}b^i&amp;#43;b\sum_{j=0}^k\binom{k}{j}a^{k-j}b^j\\&amp;amp;=\sum_{i=0}^k\binom{k}{i}a^{k-i&amp;#43;1}b^i&amp;#43;\sum_{j=0}^k\binom{k}{j}a^{k-j}b^{j&amp;#43;1}&amp;amp;&amp;amp;将 \ a,b \ 乘进去\\&amp;amp;=a^{k&amp;#43;1}&amp;#43;\sum_{i=1}^k\binom{k}{i}a^{k-i&amp;#43;1}b^i&amp;#43;\sum_{j=0}^k\binom{k}{j}a^{k-j}b^{j&amp;#43;1}&amp;amp;&amp;amp;提出 \ i=0 \ 的项\\&amp;amp;=a^{k&amp;#43;1}&amp;#43;\sum_{i=1}^k\binom{k}{i}a^{k-i&amp;#43;1}b^i&amp;#43;\sum_{λ=1}^{k&amp;#43;1}\binom{k}{λ-1}a^{k-λ&amp;#43;1}b^λ&amp;amp;&amp;amp;设 \ λ=j&amp;#43;1，代入\\&amp;amp;=a^{k&amp;#43;1}&amp;#43;\sum_{i=1}^k\binom{k}{i}a^{k-i&amp;#43;1}b^i&amp;#43;b^{k&amp;#43;1}&amp;#43;\sum_{λ=1}^{k}\binom{k}{λ-1}a^{k-λ&amp;#43;1}b^λ&amp;amp;&amp;amp;提出 \ λ=k&amp;#43;1 \ 的项\\&amp;amp;=a^{k&amp;#43;1}&amp;#43;b^{k&amp;#43;1}&amp;#43;\sum_{i=1}^k\binom{k&amp;#43;1}{i}a^{k&amp;#43;1-i}b^i&amp;amp;&amp;amp;套用 \ 帕斯卡法则\\&amp;amp;=\sum_{i=0}^{k&amp;#43;1}\binom{k&amp;#43;1}{i}a^{k&amp;#43;1-i}b^i\\\end{aligned}$$
∴ 二项式定理满足递推成立关系：
$n=k$ 时成立 $\Longrightarrow$ $n=k+1$ 时成立∵ $n=1$ 时 $(a+b)^1=\sum_{i=0}^1\binom{n}{i}a^{n-i}b^i=a+b$ 成立，
∴ 二项式定理在 $n=1$ 之后的任何整数都成立.</description>
    </item>
    
    <item>
      <title>组合数学</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</link>
      <pubDate>Sat, 21 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</guid>
      <description>注意：若无特殊说明，本章涉及的变量皆为正整数.
简介#排列：从 $n$ 个元素中取出 $m$ 个，按一定顺序排列.
组合：从 $n$ 个元素中取出 $m$ 个，不计排列顺序.
加法原理#一算法有 $n$ 种方式，第 $i$ 种方式有 $a_i$ 种方法，该算法共有 $\sum_{i=1}^na_i$ 种实现方法.
例 从 $A$ 地到 $B$ 地有爬行、骑车、飞行三种方式，可以任选一个. 而爬行、骑车、飞行分别有 $a_1,a_2,a_3$ 种方法，那么 $A→B$ 共有 $a_1+a_2+a_3$ 种方法. 乘法原理#一算法有 $n$ 个步骤，第 $i$ 个步骤有 $a_i$ 种方法，该算法共有 $\prod_{i=1}^na_i$ 种实现方法.
例 从 $A$ 地到 $B$ 地必须先爬行到车站，再骑车到机场，最后飞行到北京，而爬行、骑车、飞行分别有 $a_1,a_2,a_3$ 种方法，那么 $A→B$ 共有 $a_1\cdot a_2\cdot a_3$ 种方法. 排列数#从 $n$ 个元素中取出 $m$ 个，按一定顺序排列的方案数，用符号 $A_n^m$ 表示.</description>
    </item>
    
    <item>
      <title>欧拉函数</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</guid>
      <description>注意：若无特殊说明，本章涉及的变量皆为正整数.
定义#$n$ 的欧拉函数为 $[1,n]$ 中与 $n$ 互质的数的个数，记为 $\varphi(n)$. 特别地，$\varphi(1)=1$.
性质#质数的欧拉函数#$p$ 为质数，则 $\varphi(p)=p-1$.
证 $p$ 与 $[1,p-1]$ 中的每个数互质. $p^k$ 的欧拉函数#$p$ 为质数，$n=p^k$，则 $\varphi(n)=p^k-p^{k-1}$.
证 在 $[1,n]$ 中，只有 $p$ 的倍数不与 $n=p^k$ 互质.
$∵\;[1,n]$ 中 $p$ 的倍数有 $\dfrac{n}{p}=\dfrac{p^k}{p}=p^{k-1}$ 个，
$∴\varphi(n)=n-p^{k-1}=p^k-p^{k-1}$.
通项公式#$n$ 有 $m$ 个质因子 $p_1∼p_m$，则 $\varphi(n)=n\prod_{i=1}^{m}(1-\frac{1}{p_i})$.
证 若 $n$ 有质因子 $p$，则 $p$ 的倍数不与 $n$ 互质.
$[1,n]$ 中 $p$ 的倍数有 $\cfrac{n}{p}$ 个，则剩下的 $n-\cfrac{n}{p}=n\cdot(1-\cfrac{1}{p})$ 个数不是 $p$ 的倍数.</description>
    </item>
    
    <item>
      <title>乘法逆元</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</link>
      <pubDate>Thu, 19 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</guid>
      <description>注意：若无特殊说明，本章涉及的变量皆为正整数.
定义#若 $a\cdot b≡1\pmod{p}$，则 $b$ 为 $a$ 在模 $p$ 意义下的逆元，记作 $a^{-1}$ 或 $inv(a)$.
$$a·a^{-1}≡1 \ (\bmod \ p)$$
乘法逆元能够很好地将模运算中的除法转为乘法：
$$\dfrac{a}{b}≡a\cdot b^{-1} \ (\bmod \ p)$$
在模运算中，$a^{-1}$ 是整数，并不是 $a$ 的 $-1$ 次方.
解法#对于整数 $x$，可以求解关于 $x^{-1}$ 的 线性同余方程 $x\cdot x^{-1}≡1 \ (\bmod \ p)$，其中 $x$ 为已知常数.
int exGcd(int a, int b, int&amp;amp; x, int&amp;amp; y) { if(b == 0) { x = 1, y = 0; return a; } int d = exGcd(b, a % b, x, y); int t = x; x = y, y = t - a / b * y; return d; } int liEu(int a, int b, int c) { // a·x ≡ c (mod b) int x, y, d = exGcd(a, b, x, y); x *= (c / d); int t = b / d; return (x % t + t) % t; } int inv(int x, int m) { return liEu(x, m, 1); } 质数的逆元#当 $p$ 为质数时，由 费马小定理 得：</description>
    </item>
    
    <item>
      <title>线性同余方程</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</guid>
      <description>注意：若无特殊说明，本章涉及的变量皆为正整数.
简介#形如 $ax≡c\pmod{b}$ 的方程称为线性同余方程.
特殊解#$ax≡c\pmod{b}\eq ax+by=c$. 由 裴蜀定理 可知，当且仅当 $gcd(a,b)\mid c$ 时有整数解.
先用 扩展欧几里得算法 求出一组 $x_0,y_0$，使得：
$$ax_0+by_0=gcd(a,b)$$
两边同时乘 $\frac{c}{gcd(a,b)}$：
$$a\frac{c}{gcd(a,b)}x_0+b\frac{c}{gcd(a,b)}y_0=c$$
于是找到方程 $ax+by=c$ 的一组特殊解：
$$\left\{\begin{aligned}x=\frac{c}{gcd(a,b)}x_0\\y=\frac{c}{gcd(a,b)}y_0\end{aligned}\right.$$
通解#若 $x_0,y_0$ 为方程 $ax+by=c$ 的一组解，则该方程的任意解可表示为：
$$\left\{\begin{aligned}x=x_0&amp;#43;bt\\y=y_0-at\end{aligned}\right.$$
在实际问题中，往往只需要最小正整数解：
$$x=(x_0 \bmod t&amp;#43;t) \bmod t, \ t=\frac{b}{gcd(a,b)}$$
模板#int exGcd(int a, int b, int&amp;amp; x, int&amp;amp; y) { if (b == 0) { x = 1, y = 0; return a; } int d = exGcd(b, a % b, x, y); int t = x; x = y, y = t - a / b * y; return d; } int liEu(int a, int b, int c) { // ax ≡ c (mod b) int x, y, d = exGcd(a, b, x, y); if (c % d !</description>
    </item>
    
    <item>
      <title>欧几里得算法</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 14 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</guid>
      <description>最大公因数#$a$ 和 $b$ 的最大公因数记作 $gcd(a,b)$，简记为 $(a,b)$.
若 $a,b$ 有公因数 $d$，则 $a \bmod b = a - b \cdot\left\lfloor\frac{a}{b}\right\rfloor$ 也有因数 $d$. 也就是说，$a$ 和 $b$ 的所有公因数，同时也是 $b$ 和 $a \bmod b$ 的公因数，因此它们的最大公因数也相等.
$$gcd(a,b)=gcd(b,a \bmod b)$$
递归到 $b=0$ 时，$a$ 即为 $gcd(a,b)$.
时间复杂度为 $O(log{(a+b)})$.
int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); } 最小公倍数#$a$ 和 $b$ 的最小公倍数记作 $lcm(a,b)$，简记为 $[a,b]$.
设 $gcd(a,b)=d$，则 $a=k_1d,b=k_2d$，所以：</description>
    </item>
    
    <item>
      <title>贝祖定理</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86/</link>
      <pubDate>Sat, 14 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86/</guid>
      <description>注意：若无特殊说明，本章涉及的变量皆为正整数.
简介#对于任意 $a,b$，$ax+by=c\eq gcd(a,b)\mid c$.
证明#设 $gcd(a,b)=d$，则：
$$\left\{\begin{aligned}&amp;amp;d\mid a\\&amp;amp;d\mid b\end{aligned}\right.\eq\left\{\begin{aligned}&amp;amp;d\mid ax\\&amp;amp;d\mid by\end{aligned}\right.\eqd\mid (ax&amp;#43;by)\eqd\mid c$$
即 $gcd(a,b)\mid c$.</description>
    </item>
    
    <item>
      <title>快速幂</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Sat, 31 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>快速幂#如何快速求 $a^b$（$a,b\in\mathbb{Z}$）？
递归写法#根据乘方公式 $a^{m+n}=a^m\cdot a^n$，有：
$$a^b=\left\{\begin{aligned}&amp;amp;a^{\left\lfloor b/2\right\rfloor}\cdot a^{\left\lfloor b/2\right\rfloor} &amp;amp;&amp;amp; b=2k\\&amp;amp;a^{\left\lfloor b/2\right\rfloor}\cdot a^{\left\lfloor b/2\right\rfloor}\cdot a &amp;amp;&amp;amp; b=2k&amp;#43;1\end{aligned}\right.,k\in\mathbb{Z}$$
边界条件 时间复杂度 $a^0=1$ $O(\log{b})$ typedef long long LL; LL Pow(LL a, LL b) { if(!b) return 1; // 边界条件 LL res = Pow(a, b / 2); if(b % 2 == 0) // b 是偶数 return res * res; else // b 是奇数 return res * res * a; } 递推写法#若 $b$ 在二进制下的第 $k_1,k_2,k_3,\cdots$ 位为 $1$，则 $b=2^{k_1}+2^{k_2}+2^{k_3}+\cdots(k_i≤\log{b})$.</description>
    </item>
    
    <item>
      <title>同余</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E5%90%8C%E4%BD%99/</link>
      <pubDate>Mon, 12 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99/%E5%90%8C%E4%BD%99/</guid>
      <description>注意：若无特殊说明，本章涉及的变量皆为正整数.
定义#若 $a \bmod m=b \bmod m$，则 $a$ 和 $b$ 模 $m$ 同余，记作 $a≡b\pmod{m}$.
$$a≡b \ (\bmod \ m)\eq a=b+km\eq m\mid(a-b)$$
性质#自反性：$a≡a\pmod{m}$.
对称性：$a≡b\pmod{m}\eq b≡a\pmod{m}$.
传递性：$\left\{\begin{aligned}a&amp;amp;≡b \ (\bmod \ m)\\b&amp;amp;≡c \ (\bmod \ m)\end{aligned}\right.\eq a≡c\pmod{m}$.
同加性：$a≡b\pmod{m}\eq a+c≡b+c\pmod{m}$.
同乘性：$a≡b\pmod{m}\eq ac≡bc\pmod{m}$.
同幂性：$a≡b\pmod{m}\eq a^n≡b^n\pmod{m}$.
同余不满足同除性. 当 $a≡b \ (\bmod \ m)$ 时不一定有 $\frac{a}{n}≡\frac{b}{n} \ (\bmod \ m)$.
同余类#集合 $A$ 是模 $m$ 的同余类，当且仅当：
$A$ 中的所有元素模 $m$ 都等于同一个值 $a$. $$A=\{x\mid x \bmod m=a\}$$</description>
    </item>
    
    <item>
      <title>因数</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%9B%A0%E6%95%B0/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E5%9B%A0%E6%95%B0/</guid>
      <description>若无特殊说明，本章涉及的变量皆为正整数.
定义#若 $n \div d$ 为整数，则 $d$ 是 $n$ 的因数，记作 $d\mid n$.
算数基本定理#任意正整数 $n$ 都能唯一地分解为有限个质数的乘积.
$$n=p_1^{\normalsize c_1}\cdot p_2^{\normalsize c_2}\cdots p_m^{\normalsize c_m}$$
分解质因数#试除法#将 $n$ 分解成 算数基本定理 的形式. 如 $$360=2^3\times 3^2\times 5$$
枚举 $i=2,3,\cdots,\sqrt{n}$，除尽 $n$ 中的 $i$，并记录除的次数.
const int N = 1e6; vector&amp;lt;int&amp;gt; P, C; void factor(int n) { for (int i = 2; i &amp;lt;= sqrt(n); i ++) { if (n % i == 0) { P.</description>
    </item>
    
    <item>
      <title>质数</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0/</link>
      <pubDate>Mon, 05 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0/</guid>
      <description>若无特殊说明，本章涉及的变量皆为正整数.
定义#若 $n$ 只能被 $1$ 和 $n$ 整除，则 $n$ 是质数，否则是合数. $\pi(n)$：$n$ 以内的质数个数，$\pi(n)≈\frac{n}{\ln{n}}$. $p(n)$：第 $n$ 个质数，$p(n)≈n\ln{n}$. 质数判定#若 $n$ 为合数，则必定存在 $i≤\sqrt{n}$，使 $n$ 能整除 $i$. $n=0,1$ 需要特判.
时间复杂度：$O(\sqrt n)$.
bool isPrime(int n) { if (n &amp;lt; 2) return false; for (int i = 2; i &amp;lt;= sqrt(n); i ++) if (n % i == 0) return false; return true; } 质数筛法#求 $n$ 以内的所有质数.
暴力算法#对 $[2,n]$ 中的所有整数进行一次 质数判定.</description>
    </item>
    
    <item>
      <title>差分约束系统</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/</guid>
      <description>简介#给定差分不等式组
$$\begin{cases}X_1 - X_2 ≤ 1\\X_3 - X_2 ≤ 3\\X_4 - X_1 ≤ -2\\\cdots\end{cases}$$
求一组满足所有条件的 $X_1\cdots X_n$ 的解.
以上形式的不等式组称作「差分约束系统」.
原理#根据 松弛操作 原理，当 SPFA 程序 结束时，图中任意两个节点 $i,j$ 满足 $\dis[j] ≤ \dis[i] + g[i,j]$.
事实上，差分约束系统的不等式可以变形为
$$X_j ≤ X_i + C$$
于是令 $\dis[j]=X_j,\dis[i]=X_i,g[i,j]=C$.
在图上跑一遍 SPFA 后，$X_1\cdots X_n$ 便满足差分不等式组.
模板#bool in[], X[]; // 将 dis[] 换成 X[]，便于理解 struct node { int val, len; }; vector&amp;lt;int&amp;gt; g[]; void add(int X_j, X_i, C) { // X_j - X_i ≤ C g[X_i].</description>
    </item>
    
    <item>
      <title>强连通分量</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</link>
      <pubDate>Tue, 08 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</guid>
      <description>简介#强连通#在有向图 $G$ 中，如果同时存在 $u→v$ 和 $v→u$ 的路径，那么称 $u$ 和 $v$ 强连通.
强连通图#如果有向图 $G$ 的任意两个节点都强连通，那么称 $G$ 是强连通图.
强连通分量#如果图 $G$ 的子图是强连通图，那么该子图称作 $G$ 的强连通分量.
本章介绍求强连通分量的三种算法.
Tarjan 算法#图的结构#Tarjan 算法基于对图的 深度优先遍历（DFS），并且将图近似地看成一棵 树.因此，这棵树中会不可避免地出现一些奇怪的边.
前向边：与普通边方向一致，但跨越多个节点.
返祖边：与普通边方向相反，从子孙指向祖先.
横向边：边的两个端点居于树的同一深度.
时间戳#DFS 遍历一张图时，按访问顺序给节点打标记.$u$ 是第 $i$ 个被访问的节点，记作 $dfn[u]=i$.这个标记叫做「时间戳」.在图中，时间戳标记在节点的右上方.
$u$ $1$ $2$ $3$ $4$ $5$ $6$ $dfn[u]$ $1$ $2$ $5$ $3$ $4$ $6$ 追溯值#Tarjan 算法还引入了「追溯值」：$low[u]$，定义为以下节点时间戳的最小值：
以 $u$ 为根的子树中的所有节点.</description>
    </item>
    
    <item>
      <title>二叉堆</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E5%A0%86/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E5%A0%86/</guid>
      <description>简介#二叉堆（Binary Heap） 是一种基于完全二叉树的数据结构.
小根堆：任意节点 $≥$ 其父节点，根节点最小.
大根堆：任意节点 $≤$ 其父节点，根节点最大.
本篇以小根堆为例，介绍二叉堆的实现方式.
构造#按照从上到下，从左到右的顺序给节点编号.
该二叉堆具有以下性质：
$1$ 号节点是根节点.
$u$ 号的父节点为 $\frac{u}{2}$（向下取整）.
$u$ 号的左子节点为 $2u$，右子节点为 $2u+1$.
二叉堆的任意一条支路都按照升序排序.
使用数组保存二叉堆.
int t[], n; // t[u] : u 号节点的值 // n : 节点总数 插入#如何往小根堆中插入元素 $2$？
在堆底新建节点，值为 $2$；
对新节点所在支路进行排序.重复执行以下步骤：
若新节点 $&amp;lt;$ 其父节点，则交换它们的位置，否则跳出循环. 1 2 3 时间复杂度为 $O(n\log{n})$.
void push(int val) { // 插入元素 val t[++ n] = val; // 新建节点 for(int u = n; u !</description>
    </item>
    
    <item>
      <title>最短路径</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid>
      <description>简介#现在给你 $n$ 个节点（编号为 $1\sim n$）和它们之间的边长，求任意两个节点之间的最短路径.
松弛操作#使用 邻接矩阵 $g$ 存图.如果 $g[i,k] + g[k,j] &amp;lt; g[i,j]$，则路径 $i→k→j$ 比原先 $i→j$ 的路径更短，那么就令 $g[i,j] = g[i,k] + g[k,j]$.这就是松弛操作.
Floyed 算法#一开始，我们将所有节点全部拨到图外面，然后按 $1$ 号到 $n$ 号顺序依次往图中加入节点.
$g[k,i,j]$：当图中已经加入了 $1 \sim k$ 号节点时，从节点 $i$ 到 $j$ 的最短路径.
当节点 $k$ 被加入图中时，枚举节点 $i$ 和 $j$，利用新加入的 $k$ 对路径 $i-j$ 进行 松弛操作：
若路径 $i-j$ 不经过节点 $k$，则 $g[k,i,j] = g[k - 1,i,j]$；
若路径 $i-j$ 经过节点 $k$，则 $g[k,i,j] = g[k - 1,i,k] + g[k - 1,k,j]$.</description>
    </item>
    
    <item>
      <title>并查集</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>简介#并查集支持以下操作：
往一个集合中加入元素；
查询两个元素是否在同一集合；
合并两个集合.
问题#$\{a,b\}$，$\{e,c\}$，$\{e,d\}$ 分别在同一个集合，则共有几个集合？$b$ 和 $d$ 是否同集？
构造#把同集的两节点相连，则集合数 $=$ 连通图数. 若两节点连通，则它们同集.
并查集在每个集合中选取一个代表元素作为根节点，构造树型结构. 如图，$a,e$ 分别为两集合的代表元素.
flowcharta --&amp;gt; be --&amp;gt; ce --&amp;gt; d $fa[i]$ 为节点 $i$ 的父节点编号.上图中 $fa[b]=a$，$fa[c]=e$，$fa[d]=e$.
根节点的 $fa$ 值都设为 $0$，$fa[a]=0$，$fa[e]=0$.
查询代表元素#集合的代表元素就是并查集中的根节点.若节点 $x$ 没有父节点，则它自己是根节点，否则递归查询它的父节点.时间复杂度为 $O(\log{n})$.
int find(int x) { // 返回节点 x 的根节点 if (!fa[x]) return x; return find(fa[x]); } 查询是否同集#若两个节点所在树的根节点相同，则它们同集.
bool judge(int x, int y) { return find(x) == find(y); } 合并集合#若 $\{b,c\}$ 也同集，则合并其所在的集合.</description>
    </item>
    
    <item>
      <title>AC 自动机</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/ac-%E8%87%AA%E5%8A%A8%E6%9C%BA/</link>
      <pubDate>Sun, 30 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/ac-%E8%87%AA%E5%8A%A8%E6%9C%BA/</guid>
      <description>简介#AC 自动机不是能自动 AC 的机器，而是一种著名的多模式串匹配算法.
问题#给定 $n$ 个模式串 $A_1\sim A_n$ 和一个长为 $m$ 的主串 $S$，问有多少个模式串在 $S$ 中出现过.
假设 $n$ 个模式串互不相同，且字符串中仅含小写字母.可以考虑枚举 $S$ 的所有子串并进行判断.
int n, ans; string A[], S; int m = S.size(); for(int l = 0; l &amp;lt; m; l ++) { for(int r = l + 1; r &amp;lt; m; r ++) { string substr = S.substr(l, r - l + 1); // substr = S[l...r] for(int i = 1; i &amp;lt;= n; i ++) { if(substr == A[i]) { ans ++; } } } } cout &amp;lt;&amp;lt; ans; 暴力算法（$\textcolor{red}{×}$） AC 自动机（$\textcolor{green}{√}$） $O(n^3)$ $O(n+m)$ 原理#Under Construction .</description>
    </item>
    
    <item>
      <title>KMP 算法</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/kmp-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 28 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/kmp-%E7%AE%97%E6%B3%95/</guid>
      <description>简介#KMP 算法不是看毛片算法，而是一种字符串匹配算法. KMP 是此算法的发明者 Kruth，Morris 和 Pratt 的名字缩写.
问题#给定字符串 $A$（长度为 $m$）和 $B$（长度为 $n$），问 $A$ 中是否包含 $B$ ？
$$\begin{aligned}A&amp;amp;=a \ b \ a \ b \ a \ b \ a \ b \ c\\B&amp;amp;=a \ b \ a \ b \ c\end{aligned}$$
考虑暴力算法：
先将 $A$ 和 $B$ 左端对齐. 如果匹配失败，就将 $B$ 右移一位，直到匹配成功. $$\begin{aligned}A&amp;amp;=\textcolor{red}{a \ b \ a \ b \ a} \ b \ a \ b \ c\\B&amp;amp;=\textcolor{red}{a \ b \ a \ b \ c}\end{aligned}$$</description>
    </item>
    
    <item>
      <title>Trie 树</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/trie-%E6%A0%91/</link>
      <pubDate>Thu, 20 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/trie-%E6%A0%91/</guid>
      <description>简介#Trie 树又叫「字典树」，能够像字典一样录入和查询多个字符串.
构造#一般我们会用数组保存字符串，可是这么做既浪费空间，查询速度又慢.
const int N = 4; const string str[N] = { &amp;#34;his&amp;#34;, &amp;#34;her&amp;#34;, &amp;#34;hello&amp;#34;, &amp;#34;this&amp;#34; }; bool query(string s) { // 查询 str[] 中是否有字符串 s for(int i = 0; i &amp;lt; N; i ++) if(str[i] == s) return true; return false; } 如果将字符串放在链表里，就会有相当一部分节点可以合并.例如 his，her，hello 的开头都是 h，那么它们可以共享同一个 h 节点.同理，her 和 hello 可以共享 he.
最后，在上方建一个空节点，指向各个字符串的开头，一棵标准的 Trie 树就建好了.至于这个空节点，纯粹是为了让程序写起来更方便.
节点#Trie 树的节点存储于结构体中：
const int N = 1e6; struct Node { bool isEnd = false; // 该节点是否为某单词的末尾，默认为 false int next[26]; // 该节点的子节点 } trie[N]; 按照节点的创建顺序为其编号，令 trie[u] 表示第 $u$ 个建立的节点.</description>
    </item>
    
    <item>
      <title>最近公共祖先（LCA）</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>简介#最近公共祖先（Least Common Ancestors，简称 LCA）.
节点 $p,q$ 的最近公共祖先 $s$ 是这棵树中到 $p,q$ 的距离之和最小的节点.
如何求两个节点的 LCA？
0 $p,q$ 两个指针分别指向这两个节点，并且 $p$ 的深度比 $q$ 深. 1 将 $p$ 不断往父节点方向移，直到 $p,q$ 处于同一深度.
2 $p$ 和 $q$ 同时往父节点移，直到它们相遇于 $s$ 节点.$s$ 节点为 $p$ 和 $q$ 的 LCA.
暴力算法（$\textcolor{red}{×}$） LCA 算法（$\textcolor{green}{√}$） 预处理 $\textcolor{green}{0}$ $\textcolor{green}{O(n)}$ 单次查询 $\textcolor{red}{O(n)}$ $\textcolor{green}{O(\log{n})}$ $m$ 次查询 $\textcolor{red}{O(mn)}$ $\textcolor{green}{O(m\log{n})}$ int d[]; // d[u]: 节点 u 的深度 int f[]; // f[u]: 节点 u 的父节点 int LCA(int p, int q) { if(d[p] &amp;lt; d[q]) swap(p, q); // 使 p 的深度 ≥ q while(d[p] &amp;gt; d[q]) p = f[p]; // 步骤 1 while(p !</description>
    </item>
    
    <item>
      <title>RMQ 算法</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/rmq-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 02 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/rmq-%E7%AE%97%E6%B3%95/</guid>
      <description>简介#RMQ 是 Range Maximum/Minimum Query 的缩写，意为区间的最大（或最小）值.
问题#已知数组 $A$ 中一共有 $n$ 个元素，给出 $m$ 次询问：
给出 $l,r$，求 $A[l\cdots r]$ 中的最大值. int n, a[]; void query(int l, int r) { // 暴力算法 int ans = a[l]; for(int i = l; i &amp;lt;= r; i ++) ans = max(ans, a[i]); return ans; } 暴力算法（$\color{red}{×}$） RMQ 算法（$\color{green}{\sqrt{}}$） 预处理 $\color{green}{O(0)}$ $\color{green}{O(n\log{n})}$ 单次查询 $\color{green}{O(n)}$ $\color{green}{O(1)}$ $m$ 次询问 $\color{red}{O(mn)}$ $\color{green}{O(m)}$ 预处理#$f[i,j]$ 表示从 $A[i]$ 开始往后数 $2^j$ 个数的最大值，也就是 $\max\{A[i]\sim A[i+2^j-1]\}$.</description>
    </item>
    
    <item>
      <title>哈希表</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</link>
      <pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</guid>
      <description>简介#哈希表 由 哈希函数 和 链表 组成，相当于「超级数组」.
数组的下标1可以是整数，浮点数，字符串等.
不用定义数组的长度.
问题#医院的排队系统需要记录每个病人对应的问诊顺序.此处假设每个病人的名称都是数字.
名称 $32$ $26$ $75$ $4$ 问诊顺序 $1$ $2$ $3$ $4$ $p[i]$ 表示「名称为 $i$ 的病人的问诊顺序」.查询问诊顺序的时间复杂度为 $O(1)$.
int p[]; void update(int i, int x) { // 记录病人 i 的问诊顺序为 x p[i] = x; } int query(int i) { // 查询病人 i 的问诊顺序 return p[i]; } 然而总有某些病人不按套路取名.
名称 $114514$ $2333$ $2147483647$ $404$ 问诊顺序 $1$ $2$ $3$ $4$ 要存储 $p[2147483647]=3$，得先开一个长度为 $2147483647$ 的数组.</description>
    </item>
    
    <item>
      <title>哈希函数</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</guid>
      <description>简介#哈希函数 $getHash()$ 能够将字符串转化成整数，并保证字符串不同，对应的整数也不同.该整数称为哈希值.这样，判断两个字符串是否相等，就只要判断它们的哈希值是否相等.
原理#假设所有字符串中只包含小写字符 $a\sim z$.以字符串 fantasy 为例：
将 $a\sim z$ 替换为数字 $1\sim 26$，得到一个数列. $$fantasy→\{6,1,14,20,1,19,25\}$$
将该数列看作一个 $27$ 进制数（逢 $27$ 进一）. $$getHash(fantasy)=6\cdot 27^6+1\cdot 27^5+14\cdot 27^4+\cdots+25\cdot 27^0$$
按此方法设计的哈希函数，可保证不同字符串的哈希值必不同.但字符串长度过长时，哈希值会超出 long long 的范围.
滚动哈希#为解决一般哈希函数适用范围有限的问题，采用滚动哈希.
选取两个合适的质数 $b$ 和 $p$，将字符串看作 $b$ 进制数（$b &amp;gt;$ 字符种数）.
$getHash(fantasy)=(6\cdot b^6+1\cdot b^5+14\cdot b^4+\cdots+25\cdot b^0)\%p$按此方法设计的哈希函数，不同字符串的哈希值相同的概率较小，且哈希值不会超出 long long 的范围.时间复杂度为 $O(n)$.
typedef long long LL; const LL b = 29, p = 10000019; LL getHash(string str) { // 返回 str 的哈希值 LL h = 0; for(int i = 0; i &amp;lt; str.</description>
    </item>
    
    <item>
      <title>线段树</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>问题#数组 $A$ 中共 $n$ 个元素，对其反复进行以下操作共 $m$ 次：
单点修改：将 $A[id]$ 修改为 $v$.
区间查询：查询 $A[l\cdots r]$ 的最小值.
区间修改：将 $A[l\cdots r]$ 每个数加上 $v$.
int a[]; void set(int id, int v) { // 单点修改 a[id] = v; } int ask(int l, int r) { // 区间查询 int ans = 0; for(int i = l; i &amp;lt;= r; i ++) ans = min(ans, a[i]); return ans; } void add(int l, int r, int v) { // 区间修改 for(int i = l; i &amp;lt;= r; i ++) a[i] += v; } 暴力算法（$\textcolor{red}{×}$） 线段树（$\textcolor{green}{√}$） 单点修改 $\textcolor{green}{O(1)}$ $\textcolor{green}{O(\log{n})}$ 区间查询 $\textcolor{red}{O(n)}$ $\textcolor{green}{O(\log{n})}$ 区间修改 $\textcolor{red}{O(n)}$ $\textcolor{green}{O(\log{n})}$ $m$ 次操作 $\textcolor{red}{O(mn)}$ $\textcolor{green}{O(m\log{n})}$ 构造#查询数组 $A={6,2,3,7,1,5,4,2}$ 中的最小值时，通常使用「两两比较法」：每次比较相邻两项，只保留更小的一项.</description>
    </item>
    
    <item>
      <title>树状数组</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid>
      <description>问题#数组 $A$ 中共 $n$ 个元素，对其反复进行以下操作共 $m$ 次：
单点修改：将 $A[ x]$ 加上 $k$.
区间查询：查询 $A[l\cdots r]$ 的和.
int a[]; void set(int id, int v) { // 单点修改 a[id] = v; } int ask(int l, int r) { // 区间查询 int ans = 0; for(int i = l; i &amp;lt;= r; i ++) ans += a[i]; return ans; } 暴力算法（$\textcolor{red}{×}$） 树状数组（$\textcolor{green}{√}$） 单点修改 $\textcolor{green}{O(1)}$ $\textcolor{green}{O(\log{n})}$ 区间查询 $\textcolor{red}{O(n)}$ $\textcolor{green}{O(\log{n})}$ $m$ 次操作 $\textcolor{red}{O(mn)}$ $\textcolor{green}{O(m\log{n})}$ 构造#在原数组的上方构建树型结构，每个节点表示一段区间和：</description>
    </item>
    
    <item>
      <title>数位 DP</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8D-dp/</link>
      <pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8D-dp/</guid>
      <description>简介#如何统计区间 $[l,r]$ 中有多少整数符合某条件？
暴力算法，枚举 $[l,r]$ 中的每一个整数，逐个判断是否满足条件，此方法遇大数据必 $gg$. 优雅地使用数位 DP. 问题#统计区间 $[l,r]$（$0≤l&amp;lt;r≤100$）中有多少整数符合「相邻两个数字之差 $≥2$」.
预处理#采用「试填法」：从个位填到最高位，如果第 $d$ 位填了 $i$，那么第 $d+1$ 位只能填 $[0,i-2]$ 或 $[i+2,9]$ 中的整数.
$f[i,d]$ 表示「所有最高位为 $i$ 的 $d$ 位数中，符合条件的个数」. 通过给定条件可推出：
$$ f[i,d]=\sum_{|k-i|≥2} f[k,d-1] $$
初始条件 $f[i,1]=1$ 计算顺序 $f[0→9,2→n]$ 时间复杂度 $O(10^2\log{n})$ int f[][]; for(int i = 0; i &amp;lt;= 9; i ++) f[i][1] = 1; // 初始条件 for(int d = 2; d &amp;lt;= N; d ++) // N : 位数的上限，N ≈ log(r) for(int i = 0; i &amp;lt;= 9; i ++) for(int k = 0; k &amp;lt;= 9; k ++) if(abs(k - i) &amp;gt;= 2) f[i][d] += f[k][d - 1]; 数位统计#考虑 前缀和 思想：</description>
    </item>
    
    <item>
      <title>树形 DP</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2-dp/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2-dp/</guid>
      <description>简介#树形 DP 以树形结构为研究对象. 通常设 $f[u]$ 为树中 $u$ 号节点的值，利用树形关系推出其它节点的值. DP 过程多为 记忆化搜索.
例 1#给定一棵 $n$ 个点，$m$ 条边的树，顶点编号为 $1\sim n$，且以 $1$ 号节点为根. 以 $i$ 号节点为根的子树有几个节点？
$f[i]$：以 $i$ 号节点为根的子树的节点数.
$Son[i]$：$i$ 号节点的子节点集合.
$$f[i]=1&amp;#43;\sum_{v\in Son[i]}f[v]$$
计算顺序为 $f[$子节点$]→f[$父节点$]$. 使用记忆化搜索.
vector&amp;lt;int&amp;gt; son[]; // son[u] : 节点 u 的子节点集合 void dfs(int u) { // 求以 u 为根的子树中节点个数 f[u] = 1; for (int i = 0; i &amp;lt; son[u].size(); i ++) { int v = son[u][i]; // 节点 u 的第 i 个子节点 dfs(v); f[u] += f[v]; } } 例 2#公司有 $n$ 个人，编号为 $1\cdots n$，其中 $1$ 号员工是 boss.</description>
    </item>
    
    <item>
      <title>拓扑排序</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>简介#给出 $n$ 个元素的 $m$ 组关系：$a &amp;gt; b,a &amp;gt; c,b &amp;gt; c,b &amp;gt; d,\cdots$，试将这 $n$ 个元素按大小排序.
将上述关系转化为有向图，$a → b$ 代表 $a &amp;gt; b$.这类反映节点大小关系的图称作 AOV 网.
拓扑排序求的是符合条件的优先顺序，即拓扑序列.
原理#根据定义，没被箭头指着的节点（即入度为 $0$ 的节点）是当前最大的节点.
1 节点 $a$ 的入度为 $0$.在拓扑序列中追加 $a$，并删除 $a$ 和它的所有邻边： 拓扑序列：$a$ 2 节点 $e$ 的入度为 $0$.在拓扑序列中追加 $e$，并删除 $e$ 和它的所有邻边： 拓扑序列：$a,e$ 3 节点 $b$ 的入度为 $0$.在拓扑序列中追加 $b$，并删除 $b$ 和它的所有邻边： 拓扑序列：$a,e,b$ 4 节点 $c$ 的入度为 $0$.在拓扑序列中追加 $c$，并删除 $c$ 和它的所有邻边： 拓扑序列：$a,e,b,c$ 5 节点 $d$ 的入度为 $0$.</description>
    </item>
    
    <item>
      <title>最小生成树</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>简介#无向图 $G$ 的生成树满足以下性质：
包含 $G$ 中的所有节点. 任意两个节点都 连通. 具有 树 的所有性质. 图 $b$ 和图 $c$ 皆为图 $a$ 的生成树.
最小生成树，即边权和最小的生成树.对于 $n$ 个节点的无向图，最小生成树一定有 $n-1$ 条边.
Kruskal 算法#Kruskal 是一种贪心算法.
将 $m$ 条边按照边权升序排序； 从小到大枚举边： 若此边的两个顶点未连通，则在树中加入此边，并连通两个顶点. 若此边的两个顶点已连通，直接跳到下一条边. 重复直到树中共加入 $n-1$ 条边.
使用 并查集 判断和维护两个顶点是否连通.
时间复杂度为 $O(m\log{m})$，适用于稀疏图.
const int N = 1e6; int n, m, fa[N]; struct edge { int x, y, len; } g[N]; bool cmp(edge x, edge y) { return x.</description>
    </item>
    
    <item>
      <title>图</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E5%9B%BE/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E5%9B%BE/</guid>
      <description>定义#图（Graph） 由若干 顶点 和 边 组成，用大写字母 $G$ 表示，$V$ 为顶点集合，$E$ 为边集合，记作 $G=(V,E)$.
图是描述实际问题的工具.如进行城市道规划时，可将每个城市视作顶点，连接城市的道路视作边.
边的方向#图的每条边都有起点和终点，则图为 有向图； 相反，边没有方向（可以理解为双向）的图为 无向图（双向图）. 边权和点权#为解决实际问题，引入 边权 和 点权 的概念：
边权 及边的长度.解决最短路径问题时，将城市视作顶点，城市之间的道路长度视作边权； 点权 即点的大小.解决最小收费问题时，将收费站视作顶点，收费站之间的道路视作边，通过收费站支付的费用视作点权. 度数#若图中有 $d$ 条边与节点 $i$ 相连，则节点 $i$ 的 度数 为 $d$（即节点的 连边 个数）.如下图，节点 $1$ 的度为 $6$：
若有向图中有 $d$ 条边的 终点 是节点 $i$，则节点 $i$ 的 入度 为 $d$（即节点的 入边 个数）； 若有向图中有 $d$ 条边的 起点 是节点 $i$，则节点 $i$ 的 出度 为 $d$（即节点的 出边 个数）； 子图#图 $G$ 的子图 $H$ 满足以下条件：</description>
    </item>
    
    <item>
      <title>树</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E6%A0%91/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E5%9B%BE%E8%AE%BA/%E6%A0%91/</guid>
      <description>定义#树有多种等价的定义方式：
连通且无环的无向图. 有 $n$ 个节点和 $n-1$ 条边的无向图. 任意两个顶点间只有一条路径的无向图. 图论中的树看起来更像现实中倒悬的树：
树的节点存在「父子关系」：
有连边的两个节点中，上节点为下节点的父节点.节点 $2$ 是节点 $5$ 的父节点； 有连边的两个节点中，下节点为上节点的子节点，节点 $5$ 是节点 $2$ 的子节点； 没有父节点的节点为根节点，节点 $1$； 没有子节点的节点为叶节点，节点 $5,6,3,8,9$. 有根树和无根树#有根树必须明确根节点，而无根树的任意节点都可以是根节点.下面的左图和右图是同一棵无根树：
子树#将节点 $i$ 和其父节点断开，分裂出的以 $i$ 为根的新树，称作节点 $i$ 的子树.如下图，红色部分为节点 $3$ 的子树.
层和深度#定义根节点在第 $1$ 层，子节点层数 $=$ 父节点层数 $+ \ 1$：
树的深度 $=$ 总层数.上图中树的深度为 $4$.树中各个节点的深度为节点所在的层数.
二叉树#任意节点的子节点数量 $≤2$ 的树是二叉树：
满二叉树#深度为 $k$ 的二叉树最多有 $2^k-1$ 个节点.节点最多的那棵树是满二叉树：
满二叉树除最后一层外，其它层任意节点都有 $2$ 个子节点.</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 06 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</guid>
      <description>简介#链表只能按顺序依次访问元素，而数组支持随机访问. 链表支持在任意位置插入或删除元素，而数组不支持. 链表节点#用一个结构体表示链表的节点，其中可以存储任意数据.每个节点有 prev 和 next 两个指针，指向前后相邻的节点.
struct Node { int val; // 数据（可以是任意类型） Node *prev, *next; // 指针 }; 初始化#初始化链表时，额外建立两个节点 head 和 tail 代表链表头尾，把实际节点存储在 head 与 tail 之间，简化链表边界的判断.
Node *head, *tail; void init() { head = new Node(); tail = new Node(); head-&amp;gt;next = tail; tail-&amp;gt;prev = next; } 插入/删除节点#如何在 1 和 2 之间插入 3 ？
Step 1Step 2删除节点运用到类似的方法.</description>
    </item>
    
    <item>
      <title>栈</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</link>
      <pubDate>Fri, 05 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</guid>
      <description>简介#栈是一种「先进后出」的数据结构.类似于在桶中堆积物品，取物品时只能从顶端开始取，最先进桶的被压在最底下，最后被取出来.基本操作见 STL Stack.
表达式计算#算术表达式分为三类（$op$ 为运算符，$A,B$ 为数字或表达式）：
中缀表达式：全国人民都在用的表达式，如「$5×(3+2)$」； 前缀表达式：形如「$op \ \textcolor{red}{A} \ \textcolor{blue}{B}$」，如「$× \ \textcolor{red}{5} \ \textcolor{blue}{+} \ \textcolor{blue}{3} \ \textcolor{blue}{2}$」； 后缀表达式：形如「$\textcolor{red}{A} \ \textcolor{blue}{B} \ op$」，如「$\textcolor{red}{3} \ \textcolor{red}{2} \ \textcolor{red}{+} \ \textcolor{blue}{5} \ ×$」. 计算前/后缀表达式时，先递归求出 $A,B$ 的值，二者再做 $op$ 运算.计算方案是唯一确定的，且不需要使用括号.计算后缀表达式的算法最容易设计.
后缀表达式#定义一个栈，用于存放数； 逐一扫描后缀表达式中的元素： 若扫到一个数 $n$，则把 $n$ 入栈； 若扫到运算符 $op$ ，则弹出栈顶的两个元素，二者做 $op$ 计算.将计算结果入栈. 最终的栈顶元素就是计算结果.时间复杂度为 $O(n)$.
bool isdigit(char ch) { // 判断是否为数字 return ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;; } bool isop(char ch) { // 判断是否为运算符 return ch == &amp;#39;+&amp;#39; || ch == &amp;#39;-&amp;#39; || ch == &amp;#39;*&amp;#39; || ch == &amp;#39;/&amp;#39; || ch == &amp;#39;^&amp;#39;; } double postfix_calc(string str) { stack&amp;lt;double&amp;gt; s; int i = 0; s = stack&amp;lt;double&amp;gt;(); while(i &amp;lt; str.</description>
    </item>
    
    <item>
      <title>队列</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</link>
      <pubDate>Fri, 05 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</guid>
      <description>简介#队列是一种「先进先出」的数据结构.元素从队列的前端进入（入队），从末端离开（出队），类似于排队.基本操作见 STL Queue.
双向队列#队列元素只能从一端进，另一端出，有时无法满足问题的需要.双向队列应运而生，它支持从两端插入或删除元素.
双向队列的基本操作见 STL Deque.
单调队列#单调队列的元素从队头到队尾满足单调性，适用于查询某一动态区间的最大（或最小）元素.
插入元素#将 $A[i]$ 入队，维护队列单调性，同时保证队列元素在 $A[p\cdots i]$ 范围内.以单调递增队列为例：
重复弹出队头，直到队头 $≥p$；
重复弹出队尾，直到 $A[$队尾$]&amp;lt;A[i]$（若单调递减，则重复直到 $A[$队尾$]&amp;gt;A[i]$）.
将 $i$ 入队.
涉及双端操作，须使用双向队列.此时 $A[p\cdots i]$ 范围内最小元素为 $A[$队头$]$.
deque&amp;lt;int&amp;gt; q; // 存储元素下标 void insert(int i, int p) { // 将 a[i] 入队，维护队列元素在 a[p...i] 范围内 while(!q.empty() &amp;amp;&amp;amp; q.front() &amp;lt; p) q.pop_front(); while(!q.empty() &amp;amp;&amp;amp; a[q.back()] &amp;gt;= a[i]) q.pop_back(); q.push_back(i); } 滑动窗口#一个滑动窗口（长度为 $k$）从数组 $A$ （长度为 $n$）的左端移动到右端，每次只向右移一位.</description>
    </item>
    
    <item>
      <title>状压 DP</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8B-dp/</link>
      <pubDate>Wed, 24 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8B-dp/</guid>
      <description>简介#在程序中，我们如何保存一面棋盘？
$$\def\arraystretch{2}\begin{array}{|c|c|c|c|}\hline\ &amp; \Large♕ &amp; \ &amp; \Large♕ \\ \hline\Large♕ &amp; \ &amp; \Large♕ &amp; \Large♕ \\ \hline\ &amp; \ &amp; \Large♕ &amp; \ \\ \hline\Large♕ &amp; \Large♕ &amp; \ &amp; \Large♕ \\ \hline\end{array}$$
用 $bool$ 数组 $A[ \ ][ \ ]$.$A[i][j]=1$ 表示第 $i$ 行第 $j$ 列有一枚棋子.
bool A[][] = { {0, 1, 0, 1}, {1, 0, 1, 1}, {0, 0, 1, 0}, {1, 1, 0, 1} }; 现在我摆出了棋盘的第 $1$ 行和第 $4$ 行，并规定任意两个棋子不能相邻，则中间两行一共有多少种可行的摆法？</description>
    </item>
    
    <item>
      <title>状态压缩</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/</guid>
      <description>简介#由于 bool 变量只有 $0$ 和 $1$ 两种值，二进制位也具备此特征，故每个 bool 数组都可用一个二进制数表示.
将 bool 数组 $a$（长为 $n$）用 $n$ 位二进制数表示，它的第 $i$ 位表示 $a[i]$.
状态压缩的相关操作方法：
操作 运算 取出第 $k$ 位数 (n &amp;gt;&amp;gt; (k - 1)) &amp;amp; 1 将第 $k$ 位取反 n ^= (1 &amp;lt;&amp;lt; (k - 1)) 将第 $k$ 位赋值为 $1$ n |= (1 &amp;lt;&amp;lt; (k - 1)) 将第 $k$ 位赋值为 $0$ n &amp;amp;= ~ (1 &amp;lt;&amp;lt; (k - 1)) lowbit 运算#$lowbit(n)$：$n$ 在二进制下「最低位的 $1$ 和其后所有的 $0$」构成的数.</description>
    </item>
    
    <item>
      <title>区间 DP</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4-dp/</link>
      <pubDate>Wed, 17 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4-dp/</guid>
      <description>简介#区间 DP 以区间为研究对象. 通常设 $f[l,r]$ 为区间 $[l,r]$ 的值，用 $f[小区间]$ 的值推出 $f[大区间]$ 的值.
问题#$n$ 堆石子排成一列，第 $i$ 堆石子重量为 $A_i$. 每次合并相邻两堆石子，消耗的体力值为其重量和. 求将所有石子合并为一堆，最少消耗多少体力.
原理#$f[l,r]$：合并第 $l$ 堆至第 $r$ 堆石子的最少体力值.
合并第 $l\sim r$ 堆石子可分为三步（设 $k$ 为 $[l, r)$ 中的某个数）：
合并第 $l\sim k$ 堆石子，消耗体力值 $f[l,k]$.
合并第 $k+1\sim r$ 堆石子，消耗体力值为$f[k+1,r]$.
合并剩下两堆石子，消耗体力值 $\displaystyle\sum_{i=l}^r A_i$.
枚举 $k$，找出最小的体力值.
$$f[l,r]=\min_{l≤k&amp;lt; r}\{f[l,k]&amp;#43;f[k&amp;#43;1,r]\}&amp;#43;\sum_{i=l}^r A_i$$
其中 $\displaystyle\sum_{i=l}^r A_i$ 可以用 前缀和 优化.
计算顺序为 $f[小区间]\rightarrow f[大区间]$，故枚举区间长度的循环在最外层.
时间复杂度为 $O(n^3)$
memset(f, 0x7f, sizeof f); for (int i = 1; i &amp;lt;= n; i ++) { f[i][i] = 0; sum[i] = sum[i - 1] + a[i]; } for (int len = 2; len &amp;lt;= n; len ++) { // 区间长度 for (int l = 1; l + len - 1 &amp;lt;= n; l ++) { // 枚举区间左端点 int r = l + len - 1; // 区间右端点 for (int k = l; k &amp;lt; r; k ++) f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]); f[l][r] += sum[r] - sum[l - 1]; } } </description>
    </item>
    
    <item>
      <title>记忆化搜索</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</guid>
      <description>求 Fibonacci 第 $i$ 项的深搜程序如下：
int f(int x) { if (x &amp;lt;= 2) return 1; return f(x - 1) + f(x - 2); } 该程序直观，但运行效率低. 以 $f(7)$ 为例，列出函数调用情况：
随着 $n$ 的增大，$f(n)$ 的时间复杂度呈指数级增长. 我们发现，有很多函数被重复调用. 使用「记忆化搜索」可避免此情况.
建立数组 $F$ 保存计算结果.
若 $f(x)$ 未被调用过，算出 $f(x)$ 的值，并存入 $F[ x]$ 若 $f(x)$ 已被调用过，直接返回 $F[ x]$ int F[]; F[1] = F[2] = 1; int f(int x) { if (F[x] != 0) // 若 F[x] 有值，则说明 f(x) 被调用过 return F[x]; return F[x] = f(x - 1) + f(x - 2); // 返回时保存 } 记忆化搜索的时间复杂度与动态规划相当，但效率略低.</description>
    </item>
    
    <item>
      <title>高精度</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</guid>
      <description>简介#高精度是支持高位数的运算系统. 本章仅介绍最常用的正整数运算系统.
构造#在 vector&amp;lt;int&amp;gt; 容器内保存每位数字，并实现自动处理进位.
vector&amp;lt;int&amp;gt; 的位数要从 $0$ 记起（第 $0$ 位，第 $1$ 位，$\cdots$）.
struct Wint:vector&amp;lt;int&amp;gt; { // 以 vector 为基类 Wint(int n = 0) { // 初始化为 0 push_back(n); upgrade(); } Wint&amp;amp; upgrade() { // 处理进位 while (!empty() &amp;amp;&amp;amp; !back()) pop_back(); // 去除最高位多余的 0 if (empty()) return *this; for (int i = 1; i &amp;lt; size(); i ++) { // 满 10 进 1 (*this)[i] += (*this)[i - 1] / 10; (*this)[i - 1] %= 10; } while (back() &amp;gt;= 10) { // 最高位 &amp;gt;= 10 时，新增一位 push_back(back() / 10); (*this)[size() - 2] %= 10; } return *this; } }; 输入#取出字符串的每一位，倒序存入数组.</description>
    </item>
    
    <item>
      <title>背包问题</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85-dp/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85-dp/</guid>
      <description>01 背包#给定 $n$ 个物品，第 $i$ 个物品体积为 $c[i]$, 价值为 $w[i]$. 现有容积为 $m$ 的背包，求将物品装入背包得到的最大价值.
$f[i,v]$: 从前 $i$ 个物品中，选出总体积为 $v$ 的物品，能得到的最大价值.
不选第 $i$ 个物品：$f[i,v]=f[i-1,v]$. 选第 $i$ 个物品：$f[i,v]=f[i-1,v-w_i]+c_i$. $$f[i,v] = \max\left\{\begin{aligned}&amp;amp;f[i-1,v]\\&amp;amp;f[i-1,v-w_i]&amp;#43;c_i\quad(v≥w_i)\\\end{aligned}\right.$$
时间复杂度：$O(nm)$.
for (int i = 1; i &amp;lt;= n; i ++) { for (int v = 0; v &amp;lt;= m; v ++) { f[i][v] = f[i - 1][v]; if (v &amp;gt;= w[i]) f[i][v] = max(f[i][v], f[i - 1][v - w[i]] + c[i]); } } // 问题的解是 f[n][m] 空间优化#实际上，状态转移方程 的第一维可以去掉，即让新状态覆盖旧状态，以降低空间开销.</description>
    </item>
    
    <item>
      <title>基础 DP</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%9F%BA%E7%A1%80-dp/</link>
      <pubDate>Sat, 16 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%9F%BA%E7%A1%80-dp/</guid>
      <description>斐波那契数列#斐波那契数列是形如 $\{1,1,2,3,5,8,\cdots\}$ 的数列. 求数列的第 $n$ 项.
??? note 分析 $f[n]$：数列的第 $n$ 项.
``` latexf[n]=\begin{cases}1&amp;amp;n=1,2\\f[n-1]+f[n-2]&amp;amp;n\geq 3\end{cases}`````` cppint f[];f[1] = f[2] = 1;for (int i = 3; i &amp;lt;= n; i ++)f[i] = f[i - 1] + f[i - 2];```汉诺塔问题#汉诺塔由 $n$ 个不同的盘子和 $3$ 根杆子组成. 初始时，$n$ 个盘子从小到大叠在 $a$ 杆上：
现在，按以下规则将 $n$ 个盘子从 $a$ 杆移到 $c$ 杆.</description>
    </item>
    
    <item>
      <title>动态规划（DP）</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>简介#动态规划（DP）是打表的最高境界. 我们从一个案例入手 DP.
案例#斐波那契数列形如 $\{1,1,2,3,5,8,\cdots\}$. 计算此数列的第 $n$ 项 $f[n]$.
根据数列特征，列出递推公式
$$f[n]=\begin{cases}1&amp;amp;n=1,2\\f[n-1]&amp;#43;f[n-2]&amp;amp;n\geq 3\end{cases}$$
首先，将 $f[1]=1,f[2]=1$ 填入表.
$f[1]$ $f[2]$ $1$ $1$ 计算 $f[3]=f[2]+f[1]$ 并填入表.
$f[1]$ $f[2]$ $\color{red}{f[3]}$ $1$ $1$ $\color{red}{2}$ 计算 $f[4]=f[3]+f[2]$ 并填入表.
$f[1]$ $f[2]$ $f[3]$ $\color{red}{f[4]}$ $1$ $1$ $2$ $\color{red}{3}$ 重复计算填表的步骤，直到得到 $f[n]$.
$f[1]$ $f[2]$ $f[3]$ $f[4]$ $f[5]$ $f[6]$ $f[7]$ $\cdots$ $f[n]$ $1$ $1$ $2$ $3$ $5$ $8$ $13$ $\cdots$ 时间复杂度：$O(n)$.
f[1] = f[2] = 1; for (int i = 3; i &amp;lt;= n; i ++) f[i] = f[i - 1] + f[i - 2]; 步骤#为问题设计 状态.</description>
    </item>
    
    <item>
      <title>搜索</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/</guid>
      <description>简介#搜索算法：枚举问题的所有可能答案，并逐一校验.
案例#设集合 $A$ 满足以下性质：
若 $x\in A$，则 $2x$ 和 $3x-1$ 必属于 $A$. 已知 $3\in A$，问 $23$ 是否属于 $A$？
$A$ 的性质可抽象为下图：
$$\xymatrix@C=0em{&amp;amp; x \ar[dl]\ar[dr] &amp;amp;\\\margin 2x \margin &amp;amp; &amp;amp; 3x-1}$$
以 $3$ 为树根，向下拓展树形图. 于是只需搜索 $23$ 是否在树中.
$$\xymatrix@C=0em{&amp;amp;&amp;amp;&amp;amp;3\ar[dll]\ar[drr]\\&amp;amp;6\ar[dl]\ar[dr]&amp;amp;&amp;amp;&amp;amp;&amp;amp;8\ar[dl]\ar[dr]\\12&amp;amp;&amp;amp;17&amp;amp;&amp;amp;16&amp;amp;&amp;amp;23}$$
对于复杂的问题，可以先抽象出关系图，再搜索求解.
广度优先搜索（BFS）#广度优先搜索（Breadth First Search，BFS）按层次搜索节点. 其原理如下：
建立空队列. 将根节点入队. 取出队头，将其所有子节点入队. 重复上一步直到队列为空. BFS 搜索该图的步骤：
节点 $1$ 入队 节点 $1$ 出队，$2,3$ 入队 节点 $2$ 出队，$4,5$ 入队 节点 $3$ 出队，$6,7$ 入队 节点 $4$ 出队 节点 $5$ 出队 节点 $6$ 出队 节点 $7$ 出队 $$\xymatrix@C=0.</description>
    </item>
    
    <item>
      <title>二分</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/</link>
      <pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/</guid>
      <description>简介#玩个游戏.
想一个 $1000$ 以内的正整数 $n$. 每次我给出一个整数 $x$，告诉我「$n&amp;gt;x$」「$n&amp;lt;x$」或「$n=x$」. 我能保证在 $10$ 次以内猜到它.
首先我猜 $x=500$. 除了正好猜中以外，我能把 $n$ 的范围缩小一半.
$n&amp;gt;x\intro n\in[501,1000]$ $n&amp;lt;x\intro n\in[1,499]$ 然后如法炮制，重复给出可行范围的中间数，每次都能把范围折半. 由于 $\log_2{1000}&amp;lt;10$，最多 $10$ 次就能确定 $n$.
例 $n=324$：
$x=500$. $n&amp;lt;x\intro n\in[1,499]$. $x=250$. $n&amp;gt;x\intro n\in[251,499]$. $x=375$. $n&amp;lt;x\intro n\in[251,375]$. $x=313$. $n&amp;gt;x\intro n\in[313,375]$. $x=344$. $n&amp;lt;x\intro n\in[313,344]$. $x=328$. $n&amp;lt;x\intro n\in[313,328]$. $x=320$. $n&amp;gt;x\intro n\in[320,328]$. $x=324$. $n=x$. 条件#数组须呈现广义上的「单调性」.
将数组 $a$ 对半分，前段都不满足 $P$，后段都满足 $P$，则可用二分算法确定分割点，进而确定「第一个满足 $P$ 的元素」.
原理#查找数组 $a$（长度 $n$）中第一个满足条件 $P$ 的元素：</description>
    </item>
    
    <item>
      <title>排序</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</guid>
      <description>简介#排序数组 $a$（长度 $n$）中的元素. 本章只研究升序排序.
选择排序#在第 $i$ 次遍历中，交换 $a[i]$ 和第 $i$ 小的数.
时间复杂度：$O(n^2)$.
for (int i = 1; i &amp;lt;= n; i ++) { int tmp = i; // tmp: 第 i 小的数 for (int j = i + 1; j &amp;lt;= n; j ++) if (a[j] &amp;lt; a[tmp]) tmp = j; swap(a[i], a[tmp]); } 冒泡排序#重复扫描数组 $a$. 若 $a[i]&amp;gt;a[i+1]$ 就交换它们. 当没有可交换元素时结束排序.
时间复杂度：$O(n^2)$.
while (true) { bool swapped = false; for (int i = 1; i &amp;lt;= n; i ++) { if (a[i] &amp;gt; a[i + 1]) { swap(a[i], a[i + 1]); swapped = true; } } if (!</description>
    </item>
    
    <item>
      <title>递归</title>
      <link>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/</link>
      <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E4%BF%A1%E6%81%AF%E5%AD%A6/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/</guid>
      <description>递归的定义：参见 递归.
简介#你去找银行经理办事.
经理 A：不关我的事. 找经理 B.
经理 B：不关我的事. 找经理 A.
于是你在两个经理之间往返了一整天. 在程序中，该行为称作「递归」.
直接递归#函数 f() 在内部调用了自己.
void f() { /* Do something */ f(); } 这和以下死循环等价.
while (true) { /* Do something */ } 间接递归#这类似于两个银行经理的情况.
void A() { B(); } void B() { A(); } 边界条件#合法的递归需要边界条件，使函数在恰当的时机停止.
void f() { if (.../* 边界条件 */) return; /* Do something */ f(); } 这和以下循环等价.</description>
    </item>
    
    <item>
      <title></title>
      <link>/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>关于</title>
      <link>/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>博客主题#本站使用 Hugo 搭建，移植了 Hexo Stellar 主题，并有所改动。
Hugo Stellar Hexo Theme Stellar（原主题） 作者信息#::: - 姓名：Yharim - 性别：♂ - 年龄：Unknown - 职业：学生 - 毕业院校：福州大学 ::: latex\xymatrix@!0{&amp;amp; \lambda\omega \ar@{-}[rr]\ar@{-}&#39;[d][dd]&amp;amp; &amp;amp; \lambda C \ar@{-}[dd]\\\lambda 2 \ar@{-}[ur]\ar@{-}[rr]\ar@{-}[dd]&amp;amp; &amp;amp; \lambda P2 \ar@{-}[ur]\ar@{-}[dd]\\&amp;amp; \lambda\underline\omega \ar@{-}&#39;[r][rr]&amp;amp; &amp;amp; \lambda P\underline\omega\\\lambda{\to} \ar@{-}[rr]\ar@{-}[ur]&amp;amp; &amp;amp; \lambda P \ar@{-}[ur]}About Hugo#Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.</description>
    </item>
    
  </channel>
</rss>
